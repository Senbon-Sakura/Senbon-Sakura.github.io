<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Learning Gem5中文翻译 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Learning Gem5中文翻译">
<meta property="og:type" content="article">
<meta property="og:title" content="Learning Gem5中文翻译">
<meta property="og:url" content="http://example.com/2021/03/01/Learning-Gem5%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Learning Gem5中文翻译">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://learning.gem5.org/book/_images/simple_config.png">
<meta property="og:image" content="http://learning.gem5.org/book/_images/advanced_config.png">
<meta property="article:published_time" content="2021-02-28T17:59:25.000Z">
<meta property="article:modified_time" content="2021-03-18T18:06:46.565Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="计算机体系结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://learning.gem5.org/book/_images/simple_config.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Learning-Gem5中文翻译" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/01/Learning-Gem5%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/" class="article-date">
  <time class="dt-published" datetime="2021-02-28T17:59:25.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">技术博客</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Learning Gem5中文翻译
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- TOC -->

<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86gem5%E5%85%A5%E9%97%A8">第一部分：gem5入门</a><ul>
<li><a href="#%E6%9E%84%E5%BB%BAgem5">构建gem5</a><ul>
<li><a href="#gem5%E7%9A%84%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82">gem5的环境要求</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%A0%81">获取代码</a></li>
<li><a href="#%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9E%84%E5%BB%BAgem5">你的第一次构建gem5</a></li>
<li><a href="#gem5%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B">gem5二进制类型</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF">常见错误</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC">创建一个简单的配置脚本</a><ul>
<li><a href="#gem5%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC">gem5配置脚本</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">创建一个配置文件</a></li>
<li><a href="#%E8%BF%90%E8%A1%8Cgem5">运行gem5</a></li>
<li><a href="#simobjects%E7%A7%81%E8%AF%AD">SimObjects私语</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%BF%E7%9C%9F">完整系统与系统调用仿真</a></li>
</ul>
</li>
<li><a href="#%E5%B0%86%E7%BC%93%E5%AD%98%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC">将缓存添加到配置脚本</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1">创建缓存对象</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E7%BC%93%E5%AD%98%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">添加缓存简单的配置文件</a></li>
<li><a href="#%E5%90%91%E8%84%9A%E6%9C%AC%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0">向脚本添加参数</a></li>
</ul>
</li>
<li><a href="#%E4%BA%86%E8%A7%A3gem5%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E5%92%8C%E8%BE%93%E5%87%BA">了解gem5统计信息和输出</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC">使用默认配置脚本</a><ul>
<li><a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%B5%8F%E8%A7%88">目录结构浏览</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8sepy%E5%92%8Cfspy">使用se.py和fs.py</a><ul>
<li><a href="#sepy%E5%92%8Cfspy%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%80%89%E9%A1%B9">se.py和fs.py一些常见的选项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E4%BF%AE%E6%94%B9%E5%92%8C%E6%89%A9%E5%B1%95gem5">第二部分：修改和扩展gem5</a><ul>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%82%A8%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">设置您的开发环境</a><ul>
<li><a href="#gem5%E6%A0%B7%E5%BC%8F%E5%87%86%E5%88%99">gem5样式准则</a></li>
<li><a href="#git%E5%88%86%E6%94%AF">git分支</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E7%9A%84simobject">创建一个非常简单的SimObject</a><ul>
<li><a href="#%E6%AD%A5%E9%AA%A41%E4%B8%BA%E6%96%B0%E7%9A%84simobject%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AApython%E7%B1%BB">步骤1：为新的SimObject创建一个Python类</a></li>
<li><a href="#%E6%AD%A5%E9%AA%A42%E5%9C%A8c-%E4%B8%AD%E5%AE%9E%E7%8E%B0simobject">步骤2：在C ++中实现SimObject</a></li>
<li><a href="#%E6%AD%A5%E9%AA%A43%E6%B3%A8%E5%86%8Csimobject%E5%92%8Cc-%E6%96%87%E4%BB%B6">步骤3：注册SimObject和C ++文件</a></li>
<li><a href="#%E7%AC%AC4%E6%AD%A5%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BAgem5">第4步：（重新）构建gem5</a></li>
<li><a href="#%E6%AD%A5%E9%AA%A45%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%84simobject">步骤5：创建配置脚本以使用新的SimObject</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8git%E5%88%86%E6%94%AF">使用git分支</a></li>
</ul>
</li>
<li><a href="#%E8%B0%83%E8%AF%95gem5">调试gem5</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%B0%83%E8%AF%95%E6%A0%87%E5%BF%97">使用调试标志</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%B0%83%E8%AF%95%E6%A0%87%E5%BF%97">添加一个新的调试标志</a></li>
<li><a href="#%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BA">调试输出</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8dprintf%E4%BB%A5%E5%A4%96%E7%9A%84%E5%8A%9F%E8%83%BD">使用DPRINTF以外的功能</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BC%96%E7%A8%8B">事件驱动的编程</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83">创建一个简单的事件回调</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E4%BA%8B%E4%BB%B6">调度事件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是本教程的简介，它说了很多有趣的事情。<br>本文档的目的是向读者提供有关如何使用gem5和gem5代码库的全面介绍。本文档的目的不是提供gem5中每个功能的详细描述。阅读完本文档后，您应该在教室和计算机体系结构研究中使用gem5感到很自在。另外，您应该能够修改和扩展gem5，然后将其改进贡献到主要的gem5存储库中。<br>这份文件的背景是我在威斯康星大学麦迪逊分校（University of Wisconsin-Madison）读研究生时在过去六年中对gem5的亲身经历。所提供的示例只是做到这一点的一种方法。 与Python不同，Python的口头禅是“应该有一种-最好只有一种-明显的方式来做到这一点。” （来自Python的Zen。请参见import this），在gem5中，有多种不同的方法可以完成同一件事。因此，本书提供的许多示例都是我认为最好的处理方式的观点。<br>我学到的重要一课（困难的方法）是，在使用诸如gem5之类的复杂工具时，在使用它之前实际了解其工作原理非常重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Todo</span><br><span class="line">完成上一段，这是了解如何实际使用工具的一个好主意。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Todo</span><br><span class="line">应该添加一个术语列表。 诸如“模拟系统”与“主机系统”之类的东西。</span><br></pre></td></tr></table></figure>


<p>您可以在github上找到这本书的源代码: <a target="_blank" rel="noopener" href="https://github.com/powerjg/learning_gem5">https://github.com/powerjg/learning_gem5</a></p>
<h2 id="第一部分：gem5入门"><a href="#第一部分：gem5入门" class="headerlink" title="第一部分：gem5入门"></a>第一部分：gem5入门</h2><h3 id="构建gem5"><a href="#构建gem5" class="headerlink" title="构建gem5"></a>构建gem5</h3><p>本章详细介绍如何设置gem5开发环境和构建gem5。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Todo</span><br><span class="line">添加一个指向gem5 docker镜像的指针。 实际上，我们可能希望每个部分都有一个docker映像。</span><br></pre></td></tr></table></figure>


<h4 id="gem5的环境要求"><a href="#gem5的环境要求" class="headerlink" title="gem5的环境要求"></a>gem5的环境要求</h4><p>有关更多详细信息，请参见<a target="_blank" rel="noopener" href="http://gem5.org/Compiling_M5#Required_Software">gem5要求</a>。</p>
<p>在Ubuntu上，您可以使用以下命令安装所有必需的依赖项。 要求详细说明如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential git m4 scons zlib1g zlib1g-dev libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev python-dev python</span><br></pre></td></tr></table></figure>

<ol>
<li>git(Git)<br>gem5项目使用Git进行版本控制。  Git是一个分布式版本控制系统。 通过链接可以找到有关Git的更多信息。 默认情况下，应在大多数平台上安装Git。 但是，要在Ubuntu中安装Git，请使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></li>
<li>gcc 4.8+<br>您可能需要使用环境变量来指向gcc的非默认版本。<br>在Ubuntu上，您可以使用以下命令安装开发环境：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure></li>
<li>SCons<br>gem5使用SCons作为其构建环境。SCons就像在快速建筑上制造一样，并且在构建过程的所有方面都使用Python脚本，这是一个非常灵活（但很慢）的构建系统。<br>要在Ubuntu上使用SCons：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install scons</span><br></pre></td></tr></table></figure></li>
<li>Python 2.7+<br>gem5依赖于Python开发库。 要在Ubuntu上安装它们，请使用:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br></pre></td></tr></table></figure></li>
<li>protobuf 2.1+<br>“protocol buffers是一种与语言无关，与平台无关的可扩展机制，用于序列化结构化数据。” 在gem5中，protobuf库用于跟踪生成和回放。  protobuf不是必需的软件包，除非您计划将其用于跟踪生成和回放。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libprotobuf-dev python-protobuf protobuf-compiler libgoogle-perftools-dev</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h4><p>将目录更改为要下载gem5源的位置。 然后，要克隆存储库，请使用git clone命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;gem5.googlesource.com&#x2F;public&#x2F;gem5</span><br></pre></td></tr></table></figure>

<p>现在，您可以将目录更改为包含所有gem5代码的gem5。</p>
<h4 id="你的第一次构建gem5"><a href="#你的第一次构建gem5" class="headerlink" title="你的第一次构建gem5"></a>你的第一次构建gem5</h4><p>让我们开始构建一个基本的x86系统。当前，您必须为要模拟的每个ISA分别编译gem5。此外，如果使用<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part3/intro.html#ruby-intro-chapter">Ruby简介</a>，则每个缓存一致性协议都必须具有单独的编译。</p>
<p>要构建gem5，我们将使用SCons。SCons使用SConstruct文件（gem5/SConstruct）设置许多变量，然后在每个子目录中使用SConscript文件查找和编译所有gem5源。</p>
<p>第一次执行时，SCons会自动创建gem5/build目录。在此目录中，您会找到由SCons，编译器等生成的文件。用于编译gem5的每组选项（ISA和缓存一致性协议）将有一个单独的目录。<br>build_opts目录中有许多默认编译选项。这些文件指定最初构建gem5时传递给SCons的参数。我们将使用X86默认值，并指定我们要编译所有CPU模型。您可以查看文件build_opts/X86来查看Scons选项的默认值。您也可以在命令行上指定这些选项以覆盖任何默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons build&#x2F;X86&#x2F;gem5.opt -j9</span><br></pre></td></tr></table></figure>

<p>传递给SCons的主要参数是您要构建的内容 —— build/X86/gem5.opt。在这种情况下，我们将构建gem5.opt（带有调试符号的优化二进制文件）。 我们要在目录build/X86中构建gem5。由于该目录当前不存在，SCons将在build_opts中查找X86的默认参数。（注意：我在这里使用-j9在我的计算机上的8个内核中的9个内核上执行构建。您应该为计算机选择一个合适的编号，通常为cores + 1。）</p>
<p>输出应如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Checking for C header file Python.h... yes</span><br><span class="line">Checking for C library pthread... yes</span><br><span class="line">Checking for C library dl... yes</span><br><span class="line">Checking for C library util... yes</span><br><span class="line">Checking for C library m... yes</span><br><span class="line">Checking for C library python2.7... yes</span><br><span class="line">Checking for accept(0,0,0) in C++ library None... yes</span><br><span class="line">Checking for zlibVersion() in C++ library z... yes</span><br><span class="line">Checking for GOOGLE_PROTOBUF_VERIFY_VERSION in C++ library protobuf... yes</span><br><span class="line">Checking for clock_nanosleep(0,0,NULL,NULL) in C library None... yes</span><br><span class="line">Checking for timer_create(CLOCK_MONOTONIC, NULL, NULL) in C library None... no</span><br><span class="line">Checking for timer_create(CLOCK_MONOTONIC, NULL, NULL) in C library rt... yes</span><br><span class="line">Checking for C library tcmalloc... yes</span><br><span class="line">Checking for backtrace_symbols_fd((void*)0, 0, 0) in C library None... yes</span><br><span class="line">Checking for C header file fenv.h... yes</span><br><span class="line">Checking for C header file linux&#x2F;kvm.h... yes</span><br><span class="line">Checking size of struct kvm_xsave ... yes</span><br><span class="line">Checking for member exclude_host in struct perf_event_attr...yes</span><br><span class="line">Building in &#x2F;local.chinook&#x2F;gem5&#x2F;gem5-tutorial&#x2F;gem5&#x2F;build&#x2F;X86</span><br><span class="line">Variables file &#x2F;local.chinook&#x2F;gem5&#x2F;gem5-tutorial&#x2F;gem5&#x2F;build&#x2F;variables&#x2F;X86 not found,</span><br><span class="line">  using defaults in &#x2F;local.chinook&#x2F;gem5&#x2F;gem5-tutorial&#x2F;gem5&#x2F;build_opts&#x2F;X86</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line">scons: Building targets ...</span><br><span class="line"> [ISA DESC] X86&#x2F;arch&#x2F;x86&#x2F;isa&#x2F;main.isa -&gt; generated&#x2F;inc.d</span><br><span class="line"> [NEW DEPS] X86&#x2F;arch&#x2F;x86&#x2F;generated&#x2F;inc.d -&gt; x86-deps</span><br><span class="line"> [ENVIRONS] x86-deps -&gt; x86-environs</span><br><span class="line"> [     CXX] X86&#x2F;sim&#x2F;main.cc -&gt; .o</span><br><span class="line"> ....</span><br><span class="line"> .... &lt;lots of output&gt;</span><br><span class="line"> ....</span><br><span class="line"> [   SHCXX] nomali&#x2F;lib&#x2F;mali_midgard.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali&#x2F;lib&#x2F;mali_t6xx.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali&#x2F;lib&#x2F;mali_t7xx.cc -&gt; .os</span><br><span class="line"> [      AR]  -&gt; drampower&#x2F;libdrampower.a</span><br><span class="line"> [   SHCXX] nomali&#x2F;lib&#x2F;addrspace.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali&#x2F;lib&#x2F;mmu.cc -&gt; .os</span><br><span class="line"> [  RANLIB]  -&gt; drampower&#x2F;libdrampower.a</span><br><span class="line"> [   SHCXX] nomali&#x2F;lib&#x2F;nomali_api.cc -&gt; .os</span><br><span class="line"> [      AR]  -&gt; nomali&#x2F;libnomali.a</span><br><span class="line"> [  RANLIB]  -&gt; nomali&#x2F;libnomali.a</span><br><span class="line"> [     CXX] X86&#x2F;base&#x2F;date.cc -&gt; .o</span><br><span class="line"> [    LINK]  -&gt; X86&#x2F;gem5.opt</span><br><span class="line">scons: done building targets.</span><br></pre></td></tr></table></figure>

<p>编译完成后，您应该在build/X86/gem5.opt中有一个可运行的gem5可执行文件。编译可能会花费很长的时间，通常是15分钟或更长时间，尤其是在使用AFS或NFS之类的远程文件系统进行编译时。</p>
<h4 id="gem5二进制类型"><a href="#gem5二进制类型" class="headerlink" title="gem5二进制类型"></a>gem5二进制类型</h4><p>gem5中的SCons脚本当前具有5种可以为gem5构建的二进制文件：debug，opt，fast，prof和perf。 这些名称大多是不言自明的，但在下面进行了详细说明。</p>
<ul>
<li>debug<br>无需优化和调试符号即可构建。如果使用gem5的opt版本优化了要查看的变量，则使用调试器进行调试时，此二进制文件很有用。 与其他二进制文件相比，使用debug进行运行速度较慢。</li>
<li>opt<br>该二进制文件是使用（例如-O3）的大多数优化构建的，但其中包含调试符号。该二进制文件比debug速度快得多，但是仍然包含足够的调试信息以能够调试大多数问题。</li>
<li>fast<br>内置所有优化（包括受支持平台上的链接时优化），并且没有调试符号。 此外，所有断言都被删除，但仍然包括恐慌和致命事件。fast是性能最高的二进制文件，比opt小得多。但是，只有在您认为代码不太可能出现重大错误时，才需要使用fast。</li>
<li>prof和perf<br>这两个二进制文件是为分析gem5而构建的。prof包含有关GNU Profiler（gprof）的分析信息，而perf包含有关Google性能工具（gperftools）的分析信息。</li>
</ul>
<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><p>略！！！</p>
<h3 id="创建一个简单的配置脚本"><a href="#创建一个简单的配置脚本" class="headerlink" title="创建一个简单的配置脚本"></a>创建一个简单的配置脚本</h3><p>本教程的这一章将引导您逐步了解如何为gem5设置简单的仿真脚本以及如何首次运行gem5。 假设您已完成本教程的第一章，并且已成功使用可执行文件build/X86/gem5.opt构建了gem5。</p>
<p>我们的配置脚本将为一个非常简单的系统建模。我们只有一个简单的CPU内核。 该CPU内核将连接到系统范围的内存总线。而且，我们将有一个DDR3内存通道，该通道也已连接到内存总线。</p>
<h4 id="gem5配置脚本"><a href="#gem5配置脚本" class="headerlink" title="gem5配置脚本"></a>gem5配置脚本</h4><p>gem5二进制文件以设置和执行模拟的python脚本作为参数。在此脚本中，您将创建一个系统来模拟，创建系统的所有组件并指定系统组件的所有参数。然后，从脚本开始仿真。</p>
<p>该脚本是完全由用户定义的。您可以选择在配置脚本中使用任何有效的Python代码。本书提供了一个样式示例，该样式在Python中高度依赖类和继承。作为gem5用户，由您决定配置脚本的简单或复杂。</p>
<p>gem5在configs/examples中附带了许多示例配置脚本。 这些脚本大多数都是无所不包的，并允许用户在命令行上指定几乎所有选项。 在本书中，我们将从最简单的脚本开始，这些脚本可以运行gem5并从那里构建，而不是从这些复杂的脚本开始。 希望到本节结束时，您将对模拟脚本的工作原理有所了解。</p>
<h4 id="创建一个配置文件"><a href="#创建一个配置文件" class="headerlink" title="创建一个配置文件"></a>创建一个配置文件</h4><p>首先创建一个新的配置文件并打开它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir configs&#x2F;tutorial</span><br><span class="line">touch configs&#x2F;tutorial&#x2F;simple.py</span><br></pre></td></tr></table></figure>

<p>这只是一个普通的python文件，将由gem5可执行文件中的嵌入式python执行。因此，您可以使用python中可用的任何功能和库。</p>
<p>我们在此文件中要做的第一件事是导入m5库和我们已编译的所有SimObject。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m5</span><br><span class="line"><span class="keyword">from</span> m5.objects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>接下来，我们将创建第一个SimObject：我们将要模拟的系统。System对象将是我们模拟系统中所有其他对象的父对象。系统对象包含许多功能（非时序级别）信息，例如物理内存范围，根时钟域，根电压域，内核（在全系统仿真中）等。要创建系统SimObject，我们只是像普通的python类一样实例化它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system = System()</span><br></pre></td></tr></table></figure>

<p>现在我们已经有了要模拟的系统的参考，现在让我们在系统上设置时钟。我们首先必须创建一个时钟域。然后，我们可以在该域上设置时钟频率。 在SimObject上设置参数与在python中设置对象的成员完全相同，因此我们可以简单地将时钟设置为1 GHz。最后，我们必须为此时钟域指定一个电压域。由于我们现在不在乎系统电源，因此我们仅将默认选项用于电压域。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = <span class="string">&#x27;1GHz&#x27;</span></span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br></pre></td></tr></table></figure>

<p>建立系统后，我们来设置如何模拟内存。我们将使用<strong>timing</strong>模式进行内存模拟。除非在特殊情况下（例如快速转发和从检查点还原），否则几乎将始终使用<strong>timing</strong>模式进行内存模拟。我们还将设置一个大小为512 MB的单个内存，这是一个非常小的系统。请注意，在python配置脚本中，每当需要size时，您都可以以常见的语言和单位（例如“ 512MB”）指定该大小。同样，您可以使用时间单位（例如“ 5ns”）。这些将分别自动转换为通用表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system.mem_mode = <span class="string">&#x27;timing&#x27;</span></span><br><span class="line">system.mem_ranges = [AddrRange(<span class="string">&#x27;512MB&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>现在，我们可以创建一个CPU。 我们将从gem5中最简单的基于timing的CPU开始，即TimingSimpleCPU。该CPU模型每条指令在单个时钟周期内执行，以执行通过内存系统的内存请求（内存请求除外）。要创建CPU，您只需实例化该对象即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system.cpu = TimingSimpleCPU()</span><br></pre></td></tr></table></figure>

<p>接下来，我们将创建系统范围的内存总线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system.membus = SystemXBar()</span><br></pre></td></tr></table></figure>

<p>现在我们有了一条内存总线，让我们将CPU上的缓存端口连接到它。在这种情况下，由于我们要模拟的系统没有任何缓存，因此我们将指令缓存和数据缓存端口直接连接到内存总线。在此示例系统中，我们没有缓存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system.cpu.icache_port = system.membus.slave</span><br><span class="line">system.cpu.dcache_port = system.membus.slave</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要连接其他几个端口，以确保我们的系统正常运行。 我们需要在CPU上创建一个I/O控制器，并将其连接到内存总线。 另外，我们需要将系统中的特殊端口连接到内存总线。 此端口是仅功能端口，用于允许系统读取和写入内存。</p>
<p>将PIO和中断端口连接到内存总线是x86特定的要求。 其他ISA（例如ARM）不需要这3条额外的线。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">system.cpu.createInterruptController()</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].pio = system.membus.master</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].int_master = system.membus.slave</span><br><span class="line">system.cpu.interrupts[<span class="number">0</span>].int_slave = system.membus.master</span><br><span class="line"></span><br><span class="line">system.system_port = system.membus.slave</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要创建一个内存控制器并将其连接到membus。对于此系统，我们将使用一个简单的DDR3控制器，它将负责我们系统的整个内存范围。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system.mem_ctrl = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.<span class="built_in">range</span> = system.mem_ranges[<span class="number">0</span>]</span><br><span class="line">system.mem_ctrl.port = system.membus.master</span><br></pre></td></tr></table></figure>

<p>在完成这些最终连接之后，我们就完成了对模拟系统的实例化！ 我们的系统应该看起来像<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part1/simple_config.html#simple-config-fig">没有缓存的简单系统配置</a>。</p>
<p><img src="http://learning.gem5.org/book/_images/simple_config.png" alt="A simple system configuration without caches."><br>没有缓存的简单系统配置</p>
<p>接下来，我们需要设置希望CPU执行的进程。由于我们以系统调用仿真模式（System Emulation Mode, SE模式）执行，因此我们将CPU指向已编译的可执行文件。我们将执行一个简单的“ Hello world”程序。gem5附带了已编译的版本，因此我们将使用它。您可以指定任何为x86构建的应用程序，这些应用程序都是静态编译的。</p>
<p>首先，我们必须创建process（另一个SimObject）。然后，将process命令设置为要运行的命令。这是一个类似于argv的列表，可执行文件位于第一位置，而可执行文件的参数位于列表的其余部分。 然后，我们将CPU设置为使用进程作为其工作量，并最终在CPU中创建功能执行上下文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process = Process()</span><br><span class="line">process.cmd = [<span class="string">&#x27;tests/test-progs/hello/bin/x86/linux/hello&#x27;</span>]</span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br></pre></td></tr></table></figure>

<p>我们需要做的最后一件事是实例化系统并开始执行。 首先，我们创建Root对象。 然后我们实例化仿真。 实例化过程遍历了我们在python中创建的所有SimObject，并创建了C ++等效项。</p>
<p>注意，您不必实例化python类，然后将参数明确指定为成员变量。 您还可以将参数作为命名参数传递，例如下面的Root对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root = Root(full_system = <span class="literal">False</span>, system = system)</span><br><span class="line">m5.instantiate()</span><br></pre></td></tr></table></figure>

<p>最后，我们可以开始实际的模拟了！ 顺便说一句，gem5现在正在使用Python 3样式的打印函数，因此print不再是语句，而必须作为函数调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Beginning simulation!&quot;</span>)</span><br><span class="line">exit_event = m5.simulate()</span><br></pre></td></tr></table></figure>

<p>模拟完成后，我们就可以检查系统状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;Exiting @ tick &#123;&#125; because &#123;&#125;&#x27;</span></span><br><span class="line">      .<span class="built_in">format</span>(m5.curTick(), exit_event.getCause()))</span><br></pre></td></tr></table></figure>

<h4 id="运行gem5"><a href="#运行gem5" class="headerlink" title="运行gem5"></a>运行gem5</h4><p>现在，我们已经创建了一个简单的模拟脚本（完整版本可以在gem5/configs/learning_gem5/part1/simple.py中找到），我们可以运行gem5。gem5可以采用许多参数，但只需要一个位置参数即模拟脚本。因此，我们可以简单地从根gem5目录运行gem5：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt configs&#x2F;tutorial&#x2F;simple.py</span><br></pre></td></tr></table></figure>

<p>输出应为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled Mar 16 2018 10:24:24</span><br><span class="line">gem5 started Mar 16 2018 15:53:27</span><br><span class="line">gem5 executing on amarillo, pid 41697</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt configs&#x2F;tutorial&#x2F;simple.py</span><br><span class="line"></span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">warn: DRAM device capacity (8192 Mbytes) does not match the address range assigned (512 Mbytes)</span><br><span class="line">0: system.remote_gdb: listening for remote gdb on port 7000</span><br><span class="line">Beginning simulation!</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Hello world!</span><br><span class="line">Exiting @ tick 507841000 because exiting with last active thread context</span><br></pre></td></tr></table></figure>

<p>可以更改配置文件中的参数，并且结果应该不同。例如，如果您将系统时钟加倍，则模拟应更快地完成。或者，如果将DDR控制器更改为DDR4，性能应该会更好。</p>
<p>此外，您可以将CPU模型更改为MinorCPU以对正序CPU进行建模，或者更改为DerivO3CPU对乱序CPU进行建模。但是，请注意，DerivO3CPU当前无法与simple.py一起使用，因为DerivO3CPU需要一个具有独立指令和数据缓存的系统（DerivO3CPU确实适用于下一部分中的配置）。</p>
<p>接下来，我们将缓存添加到我们的配置文件中，以对更复杂的系统进行建模。</p>
<h4 id="SimObjects私语"><a href="#SimObjects私语" class="headerlink" title="SimObjects私语"></a>SimObjects私语</h4><p>gem5的模块化设计围绕SimObject类型构建。 仿真系统中的大多数组件都是SimObject：CPU，缓存，内存控制器，总线等。gem5将所有这些对象从C ++实现导出到python。 因此，从python配置脚本中，您可以创建任何SimObject，设置其参数并指定SimObject之间的交互。<br>有关更多信息，请参见<a target="_blank" rel="noopener" href="http://www.gem5.org/SimObjects">http://www.gem5.org/SimObjects</a>。</p>
<h4 id="完整系统与系统调用仿真"><a href="#完整系统与系统调用仿真" class="headerlink" title="完整系统与系统调用仿真"></a>完整系统与系统调用仿真</h4><p>gem5可以在两种不同的模式下运行，分别称为“系统调用仿真”和“完整系统”或SE和FS模式。在完整系统模式下（稍后在<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part5/index.html#full-system-part">第V部分：完整系统仿真</a>中介绍），gem5仿真整个硬件系统并运行未修改的内核。 完整系统模式类似于运行虚拟机。<br>另一方面，SE模式不会仿真系统中的所有设备，而是着重于仿真CPU和内存系统。SE更易于配置，因为您无需实例化实际系统中所需的所有硬件设备。 但是，SE只能仿真Linux系统调用，因此只能模拟用户模式代码。<br>如果您不需要为研究问题建模操作系统，并且想要提高性能，则应使用SE模式。但是，如果您需要对系统进行高保真建模，或者像页面表漫游这样的OS交互很重要，则应使用FS模式。</p>
<h3 id="将缓存添加到配置脚本"><a href="#将缓存添加到配置脚本" class="headerlink" title="将缓存添加到配置脚本"></a>将缓存添加到配置脚本</h3><p>以<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part1/simple_config.html#simple-config-chapter">先前的配置脚本</a>为起点，本章将逐步介绍更复杂的配置。如下图所示，我们将向系统添加一个缓存层次结构。此外，本章还将介绍对gem5统计信息的理解，以及向脚本中添加命令行参数的方法。</p>
<p><img src="http://learning.gem5.org/book/_images/advanced_config.png" alt="具有两级缓存层次结构的系统配置。"><br>具有两级缓存层次结构的系统配置</p>
<h4 id="创建缓存对象"><a href="#创建缓存对象" class="headerlink" title="创建缓存对象"></a>创建缓存对象</h4><p>我们将使用经典的缓存，而不是<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part3/intro.html#ruby-intro-chapter">Ruby</a>，因为我们正在为单个CPU系统建模，并且我们不在乎对缓存一致性进行建模。我们将扩展Cache SimObject并为我们的系统配置它。首先，我们必须了解用于配置Cache对象的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Todo</span><br><span class="line">我们应该添加指向SimObjects的链接（例如Cache），以指向gem5位置上的doxygen。</span><br></pre></td></tr></table></figure>

<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>可以在src/mem/cache/Cache.py中找到Cache SimObject声明。该Python文件定义了您可以设置SimObject的参数。在后台，实例化SimObject时，会将这些参数传递给对象的C++实现。Cache SimObject继承自下面显示的BaseCache对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> m5.params <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> m5.proxy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> MemObject <span class="keyword">import</span> MemObject</span><br><span class="line"><span class="keyword">from</span> Prefetcher <span class="keyword">import</span> BasePrefetcher</span><br><span class="line"><span class="keyword">from</span> ReplacementPolicies <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Tags <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCache</span>(<span class="params">MemObject</span>):</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;BaseCache&#x27;</span></span><br><span class="line">    abstract = <span class="literal">True</span></span><br><span class="line">    cxx_header = <span class="string">&quot;mem/cache/base.hh&quot;</span></span><br><span class="line"></span><br><span class="line">    size = Param.MemorySize(<span class="string">&quot;Capacity&quot;</span>)</span><br><span class="line">    assoc = Param.Unsigned(<span class="string">&quot;Associativity&quot;</span>)</span><br><span class="line"></span><br><span class="line">    tag_latency = Param.Cycles(<span class="string">&quot;Tag lookup latency&quot;</span>)</span><br><span class="line">    data_latency = Param.Cycles(<span class="string">&quot;Data access latency&quot;</span>)</span><br><span class="line">    response_latency = Param.Cycles(<span class="string">&quot;Latency for the return path on a miss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    warmup_percentage = Param.Percent(<span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;Percentage of tags to be touched to warm up the cache&quot;</span>)</span><br><span class="line"></span><br><span class="line">    max_miss_count = Param.Counter(<span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;Number of misses to handle before calling exit&quot;</span>)</span><br><span class="line"></span><br><span class="line">    mshrs = Param.Unsigned(<span class="string">&quot;Number of MSHRs (max outstanding requests)&quot;</span>)</span><br><span class="line">    demand_mshr_reserve = Param.Unsigned(<span class="number">1</span>, <span class="string">&quot;MSHRs reserved for demand access&quot;</span>)</span><br><span class="line">    tgts_per_mshr = Param.Unsigned(<span class="string">&quot;Max number of accesses per MSHR&quot;</span>)</span><br><span class="line">    write_buffers = Param.Unsigned(<span class="number">8</span>, <span class="string">&quot;Number of write buffers&quot;</span>)</span><br><span class="line"></span><br><span class="line">    is_read_only = Param.Bool(<span class="literal">False</span>, <span class="string">&quot;Is this cache read only (e.g. inst)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    prefetcher = Param.BasePrefetcher(NULL,<span class="string">&quot;Prefetcher attached to cache&quot;</span>)</span><br><span class="line">    prefetch_on_access = Param.Bool(<span class="literal">False</span>,</span><br><span class="line">         <span class="string">&quot;Notify the hardware prefetcher on every access (not just misses)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    tags = Param.BaseTags(BaseSetAssoc(), <span class="string">&quot;Tag store&quot;</span>)</span><br><span class="line">    replacement_policy = Param.BaseReplacementPolicy(LRURP(),</span><br><span class="line">        <span class="string">&quot;Replacement policy&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sequential_access = Param.Bool(<span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;Whether to access tags and data sequentially&quot;</span>)</span><br><span class="line"></span><br><span class="line">    cpu_side = SlavePort(<span class="string">&quot;Upstream port closer to the CPU and/or device&quot;</span>)</span><br><span class="line">    mem_side = MasterPort(<span class="string">&quot;Downstream port closer to memory&quot;</span>)</span><br><span class="line"></span><br><span class="line">    addr_ranges = VectorParam.AddrRange([AllMemory],</span><br><span class="line">         <span class="string">&quot;Address range for the CPU-side port (to allow striping)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    system = Param.System(Parent.<span class="built_in">any</span>, <span class="string">&quot;System we belong to&quot;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># Enum for cache clusivity, currently mostly inclusive or mostly</span></span><br><span class="line">\<span class="comment"># exclusive.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clusivity</span>(<span class="params">Enum</span>):</span> vals = [<span class="string">&#x27;mostly_incl&#x27;</span>, <span class="string">&#x27;mostly_excl&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>(<span class="params">BaseCache</span>):</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;Cache&#x27;</span></span><br><span class="line">    cxx_header = <span class="string">&#x27;mem/cache/cache.hh&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Control whether this cache should be mostly inclusive or mostly</span></span><br><span class="line">    <span class="comment"># exclusive with respect to upstream caches. The behaviour on a</span></span><br><span class="line">    <span class="comment"># fill is determined accordingly. For a mostly inclusive cache,</span></span><br><span class="line">    <span class="comment"># blocks are allocated on all fill operations. Thus, L1 caches</span></span><br><span class="line">    <span class="comment"># should be set as mostly inclusive even if they have no upstream</span></span><br><span class="line">    <span class="comment"># caches. In the case of a mostly exclusive cache, fills are not</span></span><br><span class="line">    <span class="comment"># allocating unless they came directly from a non-caching source,</span></span><br><span class="line">    <span class="comment"># e.g. a table walker. Additionally, on a hit from an upstream</span></span><br><span class="line">    <span class="comment"># cache a line is dropped for a mostly exclusive cache.</span></span><br><span class="line">    clusivity = Param.Clusivity(<span class="string">&#x27;mostly_incl&#x27;</span>,</span><br><span class="line">                                <span class="string">&quot;Clusivity with upstream cache&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Determine if this cache sends out writebacks for clean lines, or</span></span><br><span class="line">    <span class="comment"># simply clean evicts. In cases where a downstream cache is mostly</span></span><br><span class="line">    <span class="comment"># exclusive with respect to this cache (acting as a victim cache),</span></span><br><span class="line">    <span class="comment"># the clean writebacks are essential for performance. In general</span></span><br><span class="line">    <span class="comment"># this should be set to True for anything but the last-level</span></span><br><span class="line">    <span class="comment"># cache.</span></span><br><span class="line">    writeback_clean = Param.Bool(<span class="literal">False</span>, <span class="string">&quot;Writeback clean lines&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在BaseCache类中，有许多参数。例如，assoc是一个整数参数。在这种情况下，某些参数（例如write_buffers）具有默认值8。除非第一个参数是字符串，否则默认参数是(Param.*)的第一个参数。每个参数的字符串参数是对该参数的描述（例如，tag_latency = Param.Cycles（“ Tag lookup latency”）表示`tag_latency控制“此缓存的命中延迟”）。<br>其中许多参数没有默认值，因此我们需要在调用m5.instantiate()之前设置这些参数。</p>
<p>现在，要创建具有特定参数的缓存，我们首先要在与simple.py相同的目录configs/tutorial中创建一个新文件caches.py。第一步是导入我们将在此文件中扩展的SimObject。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> m5.objects <span class="keyword">import</span> Cache</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以像对待其他任何Python类一样对待BaseCache对象并对其进行扩展。 我们可以根据需要命名新的缓存。让我们首先创建一个L1缓存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L1Cache</span>(<span class="params">Cache</span>):</span></span><br><span class="line">    assoc = <span class="number">2</span></span><br><span class="line">    tag_latency = <span class="number">2</span></span><br><span class="line">    data_latency = <span class="number">2</span></span><br><span class="line">    response_latency = <span class="number">2</span></span><br><span class="line">    mshrs = <span class="number">4</span></span><br><span class="line">    tgts_per_mshr = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们正在设置BaseCache的一些没有默认值的参数。要查看所有可能的配置选项，并找出哪些是必需的，哪些是可选的，您必须查看SimObject的源代码。在这种情况下，我们正在使用BaseCache。</p>
<p>我们扩展了BaseCache，并在BaseCache SimObject中设置了大多数没有默认值的参数。接下来，让我们再讨论L1Cache的两个子类：L1DCache和L1ICache.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L1ICache</span>(<span class="params">L1Cache</span>):</span></span><br><span class="line">    size = <span class="string">&#x27;16kB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L1DCache</span>(<span class="params">L1Cache</span>):</span></span><br><span class="line">    size = <span class="string">&#x27;64kB&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们还创建一个带有一些合理参数的L2缓存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L2Cache</span>(<span class="params">Cache</span>):</span></span><br><span class="line">    size = <span class="string">&#x27;256kB&#x27;</span></span><br><span class="line">    assoc = <span class="number">8</span></span><br><span class="line">    tag_latency = <span class="number">20</span></span><br><span class="line">    data_latency = <span class="number">20</span></span><br><span class="line">    response_latency = <span class="number">20</span></span><br><span class="line">    mshrs = <span class="number">20</span></span><br><span class="line">    tgts_per_mshr = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>既然我们已经指定了BaseCache所需的所有必要参数，那么我们要做的就是实例化子类并将缓存连接到互连。但是，将许多对象连接到复杂的互连可以使配置文件快速增长并变得不可读。因此，首先让我们向Cache的子类中添加一些辅助函数。请记住，这些只是Python类，因此我们可以对它们执行与Python类一样的任何操作。</p>
<p>在L1高速缓存中，我们添加两个功能：connectCPU将CPU连接到高速缓存，以及connectBus将高速缓存连接到总线。 我们需要将以下代码添加到L1Cache类中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectCPU</span>(<span class="params">self, cpu</span>):</span></span><br><span class="line">    <span class="comment"># need to define this in a base class!</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectBus</span>(<span class="params">self, bus</span>):</span></span><br><span class="line">    self.mem_side = bus.slave</span><br></pre></td></tr></table></figure>

<p>接下来，我们必须为指令和数据缓存定义一个单独的connectCPU函数，因为指令缓存和数据缓存端口具有不同的名称。现在，我们的L1ICache和L1DCache类变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L1ICache</span>(<span class="params">L1Cache</span>):</span></span><br><span class="line">    size = <span class="string">&#x27;16kB&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectCPU</span>(<span class="params">self, cpu</span>):</span></span><br><span class="line">        self.cpu_side = cpu.icache_port</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L1DCache</span>(<span class="params">L1Cache</span>):</span></span><br><span class="line">    size = <span class="string">&#x27;64kB&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectCPU</span>(<span class="params">self, cpu</span>):</span></span><br><span class="line">        self.cpu_side = cpu.dcache_port</span><br></pre></td></tr></table></figure>

<p>最后，让我们向L2Cache添加函数以分别连接到内存侧和CPU侧总线。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectCPUSideBus</span>(<span class="params">self, bus</span>):</span></span><br><span class="line">    self.cpu_side = bus.master</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectMemSideBus</span>(<span class="params">self, bus</span>):</span></span><br><span class="line">    self.mem_side = bus.slave</span><br></pre></td></tr></table></figure>

<p>完整文件可在gem5源代码中找到，位于gem5/configs/learning_gem5/part1/caches.py。</p>
<h4 id="添加缓存简单的配置文件"><a href="#添加缓存简单的配置文件" class="headerlink" title="添加缓存简单的配置文件"></a>添加缓存简单的配置文件</h4><p>现在，让我们将刚刚创建的缓存添加到<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part1/simple_config.html#simple-config-chapter">上一章中创建的配置脚本中</a>。</p>
<p>首先，让我们将脚本复制到一个新名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp simple.py two_level.py</span><br></pre></td></tr></table></figure>

<p>首先，我们需要将名称从caches.py文件导入名称空间。我们可以将以下内容添加到文件顶部（在m5.objects导入之后），就像使用任何Python源代码一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> caches <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>现在，在创建CPU之后，让我们创建L1缓存：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system.cpu.icache = L1ICache()</span><br><span class="line">system.cpu.dcache = L1DCache()</span><br></pre></td></tr></table></figure>

<p>并使用我们创建的helper函数将缓存连接到CPU端口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system.cpu.icache.connectCPU(system.cpu)</span><br><span class="line">system.cpu.dcache.connectCPU(system.cpu)</span><br></pre></td></tr></table></figure>

<p>我们无法将L1缓存直接连接到L2缓存，因为L2缓存只希望有一个端口连接到它。 因此，我们需要创建一个L2总线以将我们的L1缓存连接到L2缓存。然后，我们可以使用我们的helper函数将L1缓存连接到L2总线。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system.l2bus = L2XBar()</span><br><span class="line"></span><br><span class="line">system.cpu.icache.connectBus(system.l2bus)</span><br><span class="line">system.cpu.dcache.connectBus(system.l2bus)</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以创建L2缓存并将其连接到L2总线和内存总线。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system.l2cache = L2Cache()</span><br><span class="line">system.l2cache.connectCPUSideBus(system.l2bus)</span><br><span class="line"></span><br><span class="line">system.l2cache.connectMemSideBus(system.membus)</span><br></pre></td></tr></table></figure>

<p>文件中的所有其他内容保持不变！现在，我们有了具有两级缓存层次结构的完整配置。如果您运行当前文件，则您现在应该在58513000个时钟完成操作。完整的脚本可以在gem5源代码中找到，位于gem5/configs/learning_gem5/part1/two_level.py。</p>
<h4 id="向脚本添加参数"><a href="#向脚本添加参数" class="headerlink" title="向脚本添加参数"></a>向脚本添加参数</h4><p>使用gem5进行实验时，您不想每次想用不同的参数测试系统时都编辑配置脚本。为了解决这个问题，您可以将命令行参数添加到gem5配置脚本中。同样，由于配置脚本只是Python，因此您可以使用支持参数解析的Python库。尽管optparse已被正式弃用，但gem5随附的许多配置脚本都使用了它，而不是py:mod:argparse，因为gem5的最低Python版本曾经是2.5。Python的最低版本现在是2.7，因此在编写不需要与当前gem5脚本进行交互的新脚本时，py:mod:argparse是一个更好的选择。要开始使用optparse，您可以查阅在线Python文档。</p>
<p>要在二级缓存配置中添加选项，请在导入缓存后添加一些选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line"></span><br><span class="line">parser = OptionParser()</span><br><span class="line">parser.add_option(<span class="string">&#x27;--l1i_size&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;L1 instruction cache size&quot;</span>)</span><br><span class="line">parser.add_option(<span class="string">&#x27;--l1d_size&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;L1 data cache size&quot;</span>)</span><br><span class="line">parser.add_option(<span class="string">&#x27;--l2_size&#x27;</span>, <span class="built_in">help</span>=<span class="string">&quot;Unified L2 cache size&quot;</span>)</span><br><span class="line"></span><br><span class="line">(options, args) = parser.parse_args()</span><br></pre></td></tr></table></figure>

<p>现在，您可以运行build/X86/gem5.opt configs/tutorial/two_level_opts.py –help，它将显示您刚刚添加的选项。</p>
<p>接下来，我们需要将这些选项传递到我们在配置脚本中创建的缓存上。为此，我们只需更改two_level.py即可将选项作为参数传递给缓存，作为其构造函数的参数，然后添加一个适当的构造函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system.cpu.icache = L1ICache(options)</span><br><span class="line">system.cpu.dcache = L1DCache(options)</span><br><span class="line">...</span><br><span class="line">system.l2cache = L2Cache(options)</span><br></pre></td></tr></table></figure>

<p>在caches.py中，我们需要向每个类添加构造函数（Python中的__init__函数）。从基本L1缓存开始，我们将添加一个空的构造函数，因为我们没有适用于基本L1缓存的任何参数。但是，在这种情况下，我们不能忘记调用超类的构造函数。如果跳过对超类构造函数的调用，则在尝试实例化缓存对象时，gem5的SimObject属性查找功能将失败，并且结果将为“ RuntimeError：超出最大递归深度”。因此，在L1Cache中，我们需要在静态类成员之后添加以下内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, options=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="built_in">super</span>(L1Cache, self).__init__()</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>接下来，在L1ICache中，我们需要使用我们创建的选项（l1i_size）来设置大小。 在下面的代码中，对于没有将选项传递给L1ICache构造函数以及是否在命令行上未指定选项的情况，有一些防护措施。 在这种情况下，我们将使用已经为尺寸指定的默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, options=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="built_in">super</span>(L1ICache, self).__init__(options)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> options <span class="keyword">or</span> <span class="keyword">not</span> options.l1i_size:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.size = options.l1i_size</span><br></pre></td></tr></table></figure>

<p>我们可以对L1DCache使用相同的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, options=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="built_in">super</span>(L1DCache, self).__init__(options)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> options <span class="keyword">or</span> <span class="keyword">not</span> options.l1d_size:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.size = options.l1d_size</span><br></pre></td></tr></table></figure>

<p>以及统一的L2Cache：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, options=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="built_in">super</span>(L2Cache, self).__init__()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> options <span class="keyword">or</span> <span class="keyword">not</span> options.l2_size:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.size = options.l2_size</span><br></pre></td></tr></table></figure>

<p>通过这些更改，您现在可以从命令行（如下所示）将缓存大小传递到脚本中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt configs&#x2F;tutorial&#x2F;two_level_opts.py --l2_size&#x3D;&#39;1MB&#39; --l1d_size&#x3D;&#39;128kB&#39;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled Sep  6 2015 14:17:02</span><br><span class="line">gem5 started Sep  6 2015 15:06:51</span><br><span class="line">gem5 executing on galapagos-09.cs.wisc.edu</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt ..&#x2F;tutorial&#x2F;_static&#x2F;scripts&#x2F;part1&#x2F;two_level_opts.py --l2_size&#x3D;1MB --l1d_size&#x3D;128kB</span><br><span class="line"></span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">warn: DRAM device capacity (8192 Mbytes) does not match the address range assigned (512 Mbytes)</span><br><span class="line">0: system.remote_gdb.listener: listening for remote gdb #0 on port 7000</span><br><span class="line">Beginning simulation!</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Hello world!</span><br><span class="line">Exiting @ tick 56742000 because target called exit()</span><br></pre></td></tr></table></figure>

<p>完整的脚本可以在gem5源代码中找到，位于gem5/configs/learning_gem5/part1/caches.py和gem5/configs/learning_gem5/part1/two_level.py。</p>
<h3 id="了解gem5统计信息和输出"><a href="#了解gem5统计信息和输出" class="headerlink" title="了解gem5统计信息和输出"></a>了解gem5统计信息和输出</h3><p>在运行gem5之后，除了可以打印出模拟脚本的所有信息外，在名为m5out的目录中还生成了三个文件：</p>
<ul>
<li>config.ini<br>包含为仿真创建的每个SimObject及其参数值的列表。</li>
<li>config.json<br>与config.ini相同，但格式为json。</li>
<li>stats.txt<br>为模拟注册的所有gem5统计信息的文本表示形式。</li>
</ul>
<p>这些文件的创建位置可以通过以下方式控制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--outdir&#x3D;DIR, -d DIR</span><br></pre></td></tr></table></figure>

<p>要创建的目录，其中包含gem5输出文件，包括config.ini，config.json，stats.txt以及其他文件。如果该目录中的文件已经存在，则将其覆盖。</p>
<ul>
<li><p>config.ini<br>该文件是模拟内容的确定版本。 此文件中显示了模拟的每个SimObject的所有参数，无论是在配置脚本中设置还是使用默认值。<br>下面是运行“<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part1/simple_config.html#simple-config-chapter">创建简单配置脚本</a>”中的simple.py配置文件时生成的config.ini。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[root]</span><br><span class="line">type&#x3D;Root</span><br><span class="line">children&#x3D;system</span><br><span class="line">eventq_index&#x3D;0</span><br><span class="line">full_system&#x3D;false</span><br><span class="line">sim_quantum&#x3D;0</span><br><span class="line">time_sync_enable&#x3D;false</span><br><span class="line">time_sync_period&#x3D;100000000000</span><br><span class="line">time_sync_spin_threshold&#x3D;100000000</span><br><span class="line"></span><br><span class="line">[system]</span><br><span class="line">type&#x3D;System</span><br><span class="line">children&#x3D;clk_domain cpu dvfs_handler mem_ctrl membus</span><br><span class="line">boot_osflags&#x3D;a</span><br><span class="line">cache_line_size&#x3D;64</span><br><span class="line">clk_domain&#x3D;system.clk_domain</span><br><span class="line">default_p_state&#x3D;UNDEFINED</span><br><span class="line">eventq_index&#x3D;0</span><br><span class="line">exit_on_work_items&#x3D;false</span><br><span class="line">init_param&#x3D;0</span><br><span class="line">kernel&#x3D;</span><br><span class="line">kernel_addr_check&#x3D;true</span><br><span class="line">kernel_extras&#x3D;</span><br><span class="line">kvm_vm&#x3D;Null</span><br><span class="line">load_addr_mask&#x3D;18446744073709551615</span><br><span class="line">load_offset&#x3D;0</span><br><span class="line">mem_mode&#x3D;timing</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[system.membus]</span><br><span class="line">type&#x3D;CoherentXBar</span><br><span class="line">children&#x3D;snoop_filter</span><br><span class="line">clk_domain&#x3D;system.clk_domain</span><br><span class="line">default_p_state&#x3D;UNDEFINED</span><br><span class="line">eventq_index&#x3D;0</span><br><span class="line">forward_latency&#x3D;4</span><br><span class="line">frontend_latency&#x3D;3</span><br><span class="line">p_state_clk_gate_bins&#x3D;20</span><br><span class="line">p_state_clk_gate_max&#x3D;1000000000000</span><br><span class="line">p_state_clk_gate_min&#x3D;1000</span><br><span class="line">point_of_coherency&#x3D;true</span><br><span class="line">point_of_unification&#x3D;true</span><br><span class="line">power_model&#x3D;</span><br><span class="line">response_latency&#x3D;2</span><br><span class="line">snoop_filter&#x3D;system.membus.snoop_filter</span><br><span class="line">snoop_response_latency&#x3D;4</span><br><span class="line">system&#x3D;system</span><br><span class="line">use_default_range&#x3D;false</span><br><span class="line">width&#x3D;16</span><br><span class="line">master&#x3D;system.cpu.interrupts.pio system.cpu.interrupts.int_slave system.mem_ctrl.port</span><br><span class="line">slave&#x3D;system.cpu.icache_port system.cpu.dcache_port system.cpu.interrupts.int_master system.system_port</span><br><span class="line"></span><br><span class="line">[system.membus.snoop_filter]</span><br><span class="line">type&#x3D;SnoopFilter</span><br><span class="line">eventq_index&#x3D;0</span><br><span class="line">lookup_latency&#x3D;1</span><br><span class="line">max_capacity&#x3D;8388608</span><br><span class="line">system&#x3D;system</span><br></pre></td></tr></table></figure>

<p>在这里，我们看到，在每个SimObject的描述开始时，首先是它在配置文件中创建的名称被方括号（例如[system.membus]）包围。</p>
<p>接下来，将显示SimObject的每个参数及其值，包括未在配置文件中明确设置的参数。例如，配置文件将时钟域设置为1 GHz（在这种情况下为1000 ticks）。但是，它没有设置高速缓存行大小（系统中为64）对象。</p>
<p>config.ini文件是确保您模拟自己想模拟的东西的有用工具。gem5中有许多设置默认值和覆盖默认值的可能方法。始终检查config.ini是一项明智的选择，这是对配置文件中设置的值是否传播到实际SimObject实例的健全性检查。</p>
</li>
<li><p>stats.txt</p>
<p>gem5具有灵活的统计信息生成系统。<a target="_blank" rel="noopener" href="http://www.gem5.org/Statistics">gem5 Wiki网站</a>上详细介绍了gem5统计信息。SimObject的每个实例都有自己的统计信息。在模拟结束时，或发出特殊的统计信息转储命令时，所有SimObjects的统计信息的当前状态都转储到文件中。</p>
<p>首先，统计文件包含有关执行的常规统计信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------- Begin Simulation Statistics ----------</span><br><span class="line">sim_seconds                                  0.000346                       # Number of seconds simulated</span><br><span class="line">sim_ticks                                   345518000                       # Number of ticks simulated</span><br><span class="line">final_tick                                  345518000                       # Number of ticks from beginning of simulation (restored from checkpoints and never reset)</span><br><span class="line">sim_freq                                 1000000000000                       # Frequency of simulated ticks</span><br><span class="line">host_inst_rate                                 144400                       # Simulator instruction rate (inst&#x2F;s)</span><br><span class="line">host_op_rate                                   260550                       # Simulator op (including micro ops) rate (op&#x2F;s)</span><br><span class="line">host_tick_rate                             8718625183                       # Simulator tick rate (ticks&#x2F;s)</span><br><span class="line">host_mem_usage                                 778640                       # Number of bytes of host memory used</span><br><span class="line">host_seconds                                     0.04                       # Real time elapsed on the host</span><br><span class="line">sim_insts                                        5712                       # Number of instructions simulated</span><br><span class="line">sim_ops                                         10314                       # Number of ops (including micro ops) simulated</span><br></pre></td></tr></table></figure>

<p>统计转储以———-Begin Simulation Statistics———-开始。如果在gem5执行期间存在多个统计转储，则单个文件中可能有多个。 这对于长时间运行的应用程序或从检查点还原时很常见。</p>
<p>每个统计信息都有一个名称（第一列），一个值（第二列）和描述（最后一列以＃开头）。</p>
<p>大多数统计信息从其描述中都是可以自我解释的。几个重要的统计信息包括sim_seconds（这是模拟的总模拟时间），sim_insts（这是CPU提交的指令数量）和host_inst_rate（告诉您gem5的性能）。</p>
<p>接下来，将打印SimObjects的统计信息。 例如，内存控制器统计信息。 它具有诸如每个组件读取的字节以及这些组件使用的平均带宽之类的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">system.clk_domain.voltage_domain.voltage            1                       # Voltage in Volts</span><br><span class="line">system.clk_domain.clock                          1000                       # Clock period in ticks</span><br><span class="line">system.mem_ctrl.pwrStateResidencyTicks::UNDEFINED    507841000                       # Cumulative time (in ticks) in various power states</span><br><span class="line">system.mem_ctrl.bytes_read::cpu.inst            58264                       # Number of bytes read from this memory</span><br><span class="line">system.mem_ctrl.bytes_read::cpu.data             7167                       # Number of bytes read from this memory</span><br><span class="line">system.mem_ctrl.bytes_read::total               65431                       # Number of bytes read from this memory</span><br><span class="line">system.mem_ctrl.bytes_inst_read::cpu.inst        58264                       # Number of instructions bytes read from this memory</span><br><span class="line">system.mem_ctrl.bytes_inst_read::total          58264                       # Number of instructions bytes read from this memory</span><br><span class="line">system.mem_ctrl.bytes_written::cpu.data          7160                       # Number of bytes written to this memory</span><br><span class="line">system.mem_ctrl.bytes_written::total             7160                       # Number of bytes written to this memory</span><br><span class="line">system.mem_ctrl.num_reads::cpu.inst              7283                       # Number of read requests responded to by this memory</span><br><span class="line">system.mem_ctrl.num_reads::cpu.data              1084                       # Number of read requests responded to by this memory</span><br><span class="line">system.mem_ctrl.num_reads::total                 8367                       # Number of read requests responded to by this memory</span><br><span class="line">system.mem_ctrl.num_writes::cpu.data              941                       # Number of write requests responded to by this memory</span><br><span class="line">system.mem_ctrl.num_writes::total                 941                       # Number of write requests responded to by this memory</span><br><span class="line">system.mem_ctrl.bw_read::cpu.inst           114728823                       # Total read bandwidth from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_read::cpu.data            14112685                       # Total read bandwidth from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_read::total              128841507                       # Total read bandwidth from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_inst_read::cpu.inst      114728823                       # Instruction read bandwidth from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_inst_read::total         114728823                       # Instruction read bandwidth from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_write::cpu.data           14098901                       # Write bandwidth from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_write::total              14098901                       # Write bandwidth from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_total::cpu.inst          114728823                       # Total bandwidth to&#x2F;from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_total::cpu.data           28211586                       # Total bandwidth to&#x2F;from this memory (bytes&#x2F;s)</span><br><span class="line">system.mem_ctrl.bw_total::total             142940409                       # Total bandwidth to&#x2F;from this memory (bytes&#x2F;s)</span><br></pre></td></tr></table></figure>

<p>该文件的后面是CPU统计信息，其中包含有关syscall数量，分支数量，已提交的指令总数等信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">system.cpu.dtb.walker.pwrStateResidencyTicks::UNDEFINED    507841000                       # Cumulative time (in ticks) in various power states</span><br><span class="line">system.cpu.dtb.rdAccesses                        1084                       # TLB accesses on read requests</span><br><span class="line">system.cpu.dtb.wrAccesses                         941                       # TLB accesses on write requests</span><br><span class="line">system.cpu.dtb.rdMisses                             9                       # TLB misses on read requests</span><br><span class="line">system.cpu.dtb.wrMisses                             7                       # TLB misses on write requests</span><br><span class="line">system.cpu.apic_clk_domain.clock                16000                       # Clock period in ticks</span><br><span class="line">system.cpu.interrupts.pwrStateResidencyTicks::UNDEFINED    507841000                       # Cumulative time (in ticks) in various power states</span><br><span class="line">system.cpu.itb.walker.pwrStateResidencyTicks::UNDEFINED    507841000                       # Cumulative time (in ticks) in various power states</span><br><span class="line">system.cpu.itb.rdAccesses                           0                       # TLB accesses on read requests</span><br><span class="line">system.cpu.itb.wrAccesses                        7284                       # TLB accesses on write requests</span><br><span class="line">system.cpu.itb.rdMisses                             0                       # TLB misses on read requests</span><br><span class="line">system.cpu.itb.wrMisses                            31                       # TLB misses on write requests</span><br><span class="line">system.cpu.workload.numSyscalls                    11                       # Number of system calls</span><br><span class="line">system.cpu.pwrStateResidencyTicks::ON       507841000                       # Cumulative time (in ticks) in various power states</span><br><span class="line">system.cpu.numCycles                           507841                       # number of cpu cycles simulated</span><br><span class="line">system.cpu.numWorkItemsStarted                      0                       # number of work items this cpu started</span><br><span class="line">system.cpu.numWorkItemsCompleted                    0                       # number of work items this cpu completed</span><br><span class="line">system.cpu.committedInsts                        5712                       # Number of instructions committed</span><br><span class="line">system.cpu.committedOps                         10313                       # Number of ops (including micro ops) committed</span><br><span class="line">system.cpu.num_int_alu_accesses                 10204                       # Number of integer alu accesses</span><br><span class="line">system.cpu.num_fp_alu_accesses                      0                       # Number of float alu accesses</span><br><span class="line">system.cpu.num_vec_alu_accesses                     0                       # Number of vector alu accesses</span><br><span class="line">system.cpu.num_func_calls                         221                       # number of times a function call or return occured</span><br><span class="line">system.cpu.num_conditional_control_insts          986                       # number of instructions that are conditional controls</span><br><span class="line">system.cpu.num_int_insts                        10204                       # number of integer instructions</span><br><span class="line">system.cpu.num_fp_insts                             0                       # number of float instructions</span><br><span class="line">system.cpu.num_vec_insts                            0                       # number of vector instructions</span><br><span class="line">system.cpu.num_int_register_reads               19293                       # number of times the integer registers were read</span><br><span class="line">system.cpu.num_int_register_writes               7976                       # number of times the integer registers were written</span><br><span class="line">system.cpu.num_fp_register_reads                    0                       # number of times the floating registers were read</span><br><span class="line">system.cpu.num_fp_register_writes                   0                       # number of times the floating registers were written</span><br><span class="line">system.cpu.num_vec_register_reads                   0                       # number of times the vector registers were read</span><br><span class="line">system.cpu.num_vec_register_writes                  0                       # number of times the vector registers were written</span><br><span class="line">system.cpu.num_cc_register_reads                 7020                       # number of times the CC registers were read</span><br><span class="line">system.cpu.num_cc_register_writes                3825                       # number of times the CC registers were written</span><br><span class="line">system.cpu.num_mem_refs                          2025                       # number of memory refs</span><br><span class="line">system.cpu.num_load_insts                        1084                       # Number of load instructions</span><br><span class="line">system.cpu.num_store_insts                        941                       # Number of store instructions</span><br><span class="line">system.cpu.num_idle_cycles                          0                       # Number of idle cycles</span><br><span class="line">system.cpu.num_busy_cycles                     507841                       # Number of busy cycles</span><br><span class="line">system.cpu.not_idle_fraction                        1                       # Percentage of non-idle cycles</span><br><span class="line">system.cpu.idle_fraction                            0                       # Percentage of idle cycles</span><br><span class="line">system.cpu.Branches                              1306                       # Number of branches fetched</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用默认配置脚本"><a href="#使用默认配置脚本" class="headerlink" title="使用默认配置脚本"></a>使用默认配置脚本</h3><p>在本章中，我们将探索使用gem5随附的默认配置脚本。gem5附带了许多配置脚本，可让您非常快速地使用gem5。但是，常见的陷阱是使用这些脚本而没有完全了解要模拟的内容。在使用gem5进行计算机体系结构研究时，充分了解要模拟的系统非常重要。本章将引导您完成一些重要的选项以及默认配置脚本的各个部分。</p>
<p>在最后几章中，您是从头开始创建自己的配置脚本的。这非常强大，因为它允许您指定每个单个系统参数。但是，某些系统的设置非常复杂（例如，全系统ARM或x86计算机）。幸运的是，gem5开发人员提供了许多脚本来引导构建系统的过程。</p>
<h4 id="目录结构浏览"><a href="#目录结构浏览" class="headerlink" title="目录结构浏览"></a>目录结构浏览</h4><p>gem5的所有配置文件都可以在configs/中找到。 目录结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">configs&#x2F;boot:</span><br><span class="line">ammp.rcS            halt.sh                micro_tlblat2.rcS              netperf-stream-udp-local.rcS</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">configs&#x2F;common:</span><br><span class="line">Benchmarks.py     cpu2000.py     Options.py</span><br><span class="line">Caches.py         FSConfig.py    O3_ARM_v7a.py     SysPaths.py</span><br><span class="line">CacheConfig.py    CpuConfig.py   MemConfig.py      Simulation.py</span><br><span class="line"></span><br><span class="line">configs&#x2F;dram:</span><br><span class="line">sweep.py</span><br><span class="line"></span><br><span class="line">configs&#x2F;example:</span><br><span class="line">fs.py       read_config.py       ruby_mem_test.py      ruby_random_test.py</span><br><span class="line">memtest.py  ruby_direct_test.py  ruby_network_test.py  se.py</span><br><span class="line"></span><br><span class="line">configs&#x2F;ruby:</span><br><span class="line">MESI_Three_Level.py  MI_example.py           MOESI_CMP_token.py  Network_test.py</span><br><span class="line">MESI_Two_Level.py    MOESI_CMP_directory.py  MOESI_hammer.py     Ruby.py</span><br><span class="line"></span><br><span class="line">configs&#x2F;splash2:</span><br><span class="line">cluster.py  run.py</span><br><span class="line"></span><br><span class="line">configs&#x2F;topologies:</span><br><span class="line">BaseTopology.py  Cluster.py  Crossbar.py  MeshDirCorners.py  Mesh.py  Pt2Pt.py  Torus.py</span><br></pre></td></tr></table></figure>

<p>每个目录的简要说明如下：</p>
<ul>
<li>boot/<br>这些是在完整系统模式下使用的rcS文件。这些文件在Linux引导后由模拟器加载，并由Shell执行。在全系统模式下运行时，其中大多数用于控制基准。其中一些是实用程序功能，例如hack_back_ckpt.rcS。 这些文件将在全系统仿真一章中更深入地介绍。</li>
<li>common/<br>该目录包含许多帮助程序脚本和创建模拟系统的功能。例如，Caches.py与前面各章中创建的caches.py和caches_opts.py文件相似。<br>Options.py包含可以在命令行上设置的各种选项。 像CPU的数量，系统时钟等等。 这是查看是否要更改的选项是否已包含命令行参数的好地方。<br>CacheConfig.py包含用于设置经典内存系统的缓存参数的选项和功能。<br>MemConfig.py提供了一些用于设置内存系统的帮助程序功能。<br>FSConfig.py包含必要的功能，可为许多不同类型的系统设置全系统仿真。全系统仿真将在本章中进一步讨论。<br>Simulation.py包含许多帮助函数，用于设置和运行gem5。此文件中包含的许多代码都用于管理保存和还原检查点。下列example/中的示例配置文件使用该文件中的功能来执行gem5仿真。该文件非常复杂，但是它在模拟的运行方式上也提供了很大的灵活性。</li>
<li>dram/<br>包含用于测试DRAM的脚本。</li>
<li>example/<br>该目录包含一些示例gem5配置脚本，可以直接使用它们来运行gem5。具体来说，se.py和fs.py非常有用。有关这些文件的更多信息，请参见下一部分。此目录中还有一些其他实用程序配置脚本。</li>
<li>ruby/<br>此目录包含Ruby及其随附的缓存一致性协议的配置脚本。更多细节可以在Ruby一章中找到。</li>
<li>splash2/<br>该目录包含用于运行splash2基准套件的脚本，其中包含一些用于配置模拟系统的选项。</li>
<li>topologies/<br>该目录包含创建Ruby缓存层次结构时可以使用的拓扑的实现。更多细节可以在Ruby一章中找到。</li>
</ul>
<h3 id="使用se-py和fs-py"><a href="#使用se-py和fs-py" class="headerlink" title="使用se.py和fs.py"></a>使用se.py和fs.py</h3><p>在本节中，我将讨论一些可以在命令行上传递给se.py和fs.py的常用选项。有关如何运行全系统模拟的更多详细信息，请参见“全系统模拟”一章。在这里，我将讨论两个文件共有的选项。</p>
<p>本节中讨论的大多数选项都可以在Options.py中找到，并已在addCommonOptions函数中注册。本节未详细介绍所有选项，要查看所有选项，请使用–help运行配置脚本，或阅读脚本的源代码。</p>
<p>首先，我们简单地运行不带任何参数的hello world程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt configs&#x2F;example&#x2F;se.py --cmd&#x3D;tests&#x2F;test-progs&#x2F;hello&#x2F;bin&#x2F;x86&#x2F;linux&#x2F;hello</span><br></pre></td></tr></table></figure>

<p>并获得以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled Jan 14 2015 16:11:34</span><br><span class="line">gem5 started Feb  2 2015 15:22:24</span><br><span class="line">gem5 executing on mustardseed.cs.wisc.edu</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt configs&#x2F;example&#x2F;se.py --cmd&#x3D;tests&#x2F;test-progs&#x2F;hello&#x2F;bin&#x2F;x86&#x2F;linux&#x2F;hello</span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">warn: DRAM device capacity (8192 Mbytes) does not match the address range assigned (512 Mbytes)</span><br><span class="line">0: system.remote_gdb.listener: listening for remote gdb #0 on port 7000</span><br><span class="line">**** REAL SIMULATION ****</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Hello world!</span><br><span class="line">Exiting @ tick 5942000 because target called exit()</span><br></pre></td></tr></table></figure>

<p>但是，这根本不是一个非常有趣的模拟！默认情况下，gem5使用原子CPU并使用原子内存访问，因此没有实际的时序数据报告！要确认这一点，您可以查看m5out/config.ini。CPU显示在第46行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[system.cpu]</span><br><span class="line">type&#x3D;AtomicSimpleCPU</span><br><span class="line">children&#x3D;apic_clk_domain dtb interrupts isa itb tracer workload</span><br><span class="line">branchPred&#x3D;Null</span><br><span class="line">checker&#x3D;Null</span><br><span class="line">clk_domain&#x3D;system.cpu_clk_domain</span><br><span class="line">cpu_id&#x3D;0</span><br><span class="line">do_checkpoint_insts&#x3D;true</span><br><span class="line">do_quiesce&#x3D;true</span><br><span class="line">do_statistics_insts&#x3D;true</span><br></pre></td></tr></table></figure>

<p>要在计时模式下实际运行gem5，请指定CPU类型。在此期间，我们还可以指定L1缓存的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt configs&#x2F;example&#x2F;se.py --cmd&#x3D;tests&#x2F;test-progs&#x2F;hello&#x2F;bin&#x2F;x86&#x2F;linux&#x2F;hello --cpu-type&#x3D;TimingSimpleCPU --l1d_size&#x3D;64kB --l1i_size&#x3D;16kB</span><br><span class="line"></span><br><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled Jan 14 2015 16:11:34</span><br><span class="line">gem5 started Feb  2 2015 15:26:57</span><br><span class="line">gem5 executing on mustardseed.cs.wisc.edu</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt configs&#x2F;example&#x2F;se.py --cmd&#x3D;tests&#x2F;test-progs&#x2F;hello&#x2F;bin&#x2F;x86&#x2F;linux&#x2F;hello --cpu-type&#x3D;TimingSimpleCPU --l1d_size&#x3D;64kB --l1i_size&#x3D;16kB</span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">warn: DRAM device capacity (8192 Mbytes) does not match the address range assigned (512 Mbytes)</span><br><span class="line">0: system.remote_gdb.listener: listening for remote gdb #0 on port 7000</span><br><span class="line">**** REAL SIMULATION ****</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Hello world!</span><br><span class="line">Exiting @ tick 344986500 because target called exit()</span><br></pre></td></tr></table></figure>

<p>现在，让我们检查config.ini文件，并确保将这些选项正确传播到最终系统。 如果在m5out/config.ini中搜索“cache”，则会发现未创建任何缓存！ 即使我们指定了缓存的大小，也没有指定系统应使用缓存，因此未创建缓存。 正确的命令行应为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt configs&#x2F;example&#x2F;se.py --cmd&#x3D;tests&#x2F;test-progs&#x2F;hello&#x2F;bin&#x2F;x86&#x2F;linux&#x2F;hello --cpu-type&#x3D;TimingSimpleCPU --l1d_size&#x3D;64kB --l1i_size&#x3D;16kB --caches</span><br><span class="line"></span><br><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled Jan 14 2015 16:11:34</span><br><span class="line">gem5 started Feb  2 2015 15:29:20</span><br><span class="line">gem5 executing on mustardseed.cs.wisc.edu</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt configs&#x2F;example&#x2F;se.py --cmd&#x3D;tests&#x2F;test-progs&#x2F;hello&#x2F;bin&#x2F;x86&#x2F;linux&#x2F;hello --cpu-type&#x3D;TimingSimpleCPU --l1d_size&#x3D;64kB --l1i_size&#x3D;16kB --caches</span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">warn: DRAM device capacity (8192 Mbytes) does not match the address range assigned (512 Mbytes)</span><br><span class="line">0: system.remote_gdb.listener: listening for remote gdb #0 on port 7000</span><br><span class="line">**** REAL SIMULATION ****</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Hello world!</span><br><span class="line">Exiting @ tick 29480500 because target called exit()</span><br></pre></td></tr></table></figure>

<p>在最后一行，我们看到总时间从344986500个周期变为29480500个周期，速度要快得多！看起来缓存现在可能已启用。但是，最好再次检查config.ini文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[system.cpu.dcache]</span><br><span class="line">type&#x3D;BaseCache</span><br><span class="line">children&#x3D;tags</span><br><span class="line">addr_ranges&#x3D;0:18446744073709551615</span><br><span class="line">assoc&#x3D;2</span><br><span class="line">clk_domain&#x3D;system.cpu_clk_domain</span><br><span class="line">demand_mshr_reserve&#x3D;1</span><br><span class="line">eventq_index&#x3D;0</span><br><span class="line">forward_snoops&#x3D;true</span><br><span class="line">hit_latency&#x3D;2</span><br><span class="line">is_top_level&#x3D;true</span><br><span class="line">max_miss_count&#x3D;0</span><br><span class="line">mshrs&#x3D;4</span><br><span class="line">prefetch_on_access&#x3D;false</span><br><span class="line">prefetcher&#x3D;Null</span><br><span class="line">response_latency&#x3D;2</span><br><span class="line">sequential_access&#x3D;false</span><br><span class="line">size&#x3D;65536</span><br><span class="line">system&#x3D;system</span><br><span class="line">tags&#x3D;system.cpu.dcache.tags</span><br><span class="line">tgts_per_mshr&#x3D;20</span><br><span class="line">two_queue&#x3D;false</span><br><span class="line">write_buffers&#x3D;8</span><br><span class="line">cpu_side&#x3D;system.cpu.dcache_port</span><br><span class="line">mem_side&#x3D;system.membus.slave[2]</span><br></pre></td></tr></table></figure>

<h4 id="se-py和fs-py一些常见的选项"><a href="#se-py和fs-py一些常见的选项" class="headerlink" title="se.py和fs.py一些常见的选项"></a>se.py和fs.py一些常见的选项</h4><p>运行如下指令时会打印所有可能的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt configs&#x2F;example&#x2F;se.py --help</span><br></pre></td></tr></table></figure>

<p>以下是该列表中的一些重要选项。</p>
<ul>
<li>–cpu-type=CPU_TYPE<br>要运行的cpu的类型。这是始终设置的重要参数。默认值为atomic，它不执行时序仿真。</li>
<li>–sys-clock=SYS_CLOCK<br>以系统速度运行的块的顶层时钟。</li>
<li>–cpu-clock=CPU_CLOCK<br>以CPU速度运行的块的时钟。这与上面的系统时钟是分开的。</li>
<li>–mem-type=MEM_TYPE<br>要使用的内存类型。选项包括不同的DDR内存和ruby内存控制器。</li>
<li>–caches<br>使用经典缓存执行仿真。</li>
<li>–l2cache<br>如果使用经典缓存，请使用L2缓存执行仿真。</li>
<li>–ruby<br>使用Ruby代替传统的高速缓存作为高速缓存系统模拟。</li>
<li>-m TICKS, –abs-max-tick=TICKS<br>运行到指定的绝对模拟周期，包括来自已还原检查点的周期。如果您只想模拟一定数量的模拟时间，这将很有用。</li>
<li>-I MAXINSTS, –maxinsts=MAXINSTS<br>要模拟的指令总数（默认值：永远运行）。如果要在执行一定数量的指令后停止仿真，此功能很有用。</li>
<li>-c CMD, –cmd=CMD<br>在系统调用仿真模式下运行的二进制文件。</li>
<li>-o OPTIONS, –options=OPTIONS<br>传递给二进制文件的选项，使用“”扩起整个字符串。当您运行带有选项的命令时，这很有用。您可以通过此变量传递参数和选项（例如–whatever）。</li>
<li>–output=OUTPUT<br>将标准输出重定向到文件。如果您想将模拟应用程序的输出重定向到文件而不是打印到屏幕，这将很有用。注意：要重定向gem5输出，必须在配置脚本之前传递参数。</li>
<li>–errout=ERROUT<br>将stderr重定向到文件。与上面类似。</li>
</ul>
<h2 id="第二部分：修改和扩展gem5"><a href="#第二部分：修改和扩展gem5" class="headerlink" title="第二部分：修改和扩展gem5"></a>第二部分：修改和扩展gem5</h2><h3 id="设置您的开发环境"><a href="#设置您的开发环境" class="headerlink" title="设置您的开发环境"></a>设置您的开发环境</h3><p>这将谈论开始开发gem5的问题。</p>
<h4 id="gem5样式准则"><a href="#gem5样式准则" class="headerlink" title="gem5样式准则"></a>gem5样式准则</h4><p>修改任何开源项目时，请务必遵循项目的样式准则。您可以在<a target="_blank" rel="noopener" href="http://gem5.org/Coding_Style">gem5 Wiki</a>页面上找到有关gem5样式的详细信息。</p>
<p>为了帮助您符合样式准则，gem5包含一个脚本，该脚本在您在git中提交变更集时运行。首次构建gem5时，SCons应将此脚本自动添加到您的.git/config文件中。请不要忽略这些警告/错误。但是，在极少数情况下，如果您尝试提交不符合gem5样式准则的文件（例如，gem5源代码树之外的内容），则可以使用git选项–no-verify跳过运行 样式检查器。</p>
<p>样式指南的主要内容是：</p>
<ul>
<li>使用4个空格，而不是制表符</li>
<li>排序包含</li>
<li>对于类名，请使用大写的驼峰大小写；对于成员变量，请使用驼峰大小写；对于局部变量，请使用下划线。</li>
<li>注释您的代码</li>
</ul>
<h4 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h4><p>大多数使用gem5开发的人都使用git的分支功能来跟踪他们的更改。这使得将更改提交回gem5非常简单。此外，使用分支可以使其他人进行的新更改更容易更新gem5，同时将您自己的更改分开<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2">Git书</a>中有<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell">一章</a>很棒，描述了如何使用分支的细节。</p>
<h3 id="创建一个非常简单的SimObject"><a href="#创建一个非常简单的SimObject" class="headerlink" title="创建一个非常简单的SimObject"></a>创建一个非常简单的SimObject</h3><p>gem5中几乎所有对象都继承自基本SimObject类型。SimObjects将主接口导出到gem5中的所有对象。SimObject是包装的C ++对象，可从Python配置脚本访问。</p>
<p>SimObjects可以具有许多参数，这些参数是通过Python配置文件设置的。除了简单的参数（例如整数和浮点数）外，它们还可以具有其他SimObjects作为参数。这使您可以创建复杂的系统层次结构，例如真实的计算机。</p>
<p>在本章中，我们将逐步创建一个简单的“ HelloWorld” SimObject。目的是向您介绍如何创建SimObject，以及所有SimObject所需的样板代码。我们还将创建一个简单的Python配置脚本来实例化SimObject。</p>
<p>在接下来的几章中，我们将使用这个简单的SimObject并对其进行扩展，以包括<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part2/debugging-chapter">调试支持</a>，<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part2/events-chapter">动态事件</a>和<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part2/parameters-chapter">参数</a>。</p>
<h4 id="步骤1：为新的SimObject创建一个Python类"><a href="#步骤1：为新的SimObject创建一个Python类" class="headerlink" title="步骤1：为新的SimObject创建一个Python类"></a>步骤1：为新的SimObject创建一个Python类</h4><p>每个SimObject都有一个与之关联的Python类。此类Python描述了可以从Python配置文件中控制的SimObject的参数。对于我们简单的SimObject，我们将从没有任何参数开始。因此，我们只需要为SimObject声明一个新类并设置其名称和C ++头文件即可定义SimObject的C ++类。</p>
<p>我们可以在src/learning_gem5中创建一个文件HelloObject.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> m5.params <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> m5.SimObject <span class="keyword">import</span> SimObject</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloObject</span>(<span class="params">SimObject</span>):</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;HelloObject&#x27;</span></span><br><span class="line">    cxx_header = <span class="string">&quot;learning_gem5/hello_object.hh&quot;</span></span><br></pre></td></tr></table></figure>

<p>您可以在<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/_downloads/HelloObject.py">此处</a>找到完整的文件。</p>
<p>不需要类型与类的名称相同，但这是约定。该类型是您与此Python SimObject包装的C ++类。仅在特殊情况下，类型和类名才可以不同。</p>
<p>cxx_header是包含用作类型参数的类的声明的文件。同样，惯例是将SimObject的名称全部使用小写和下划线，但这只是惯例。您可以在此处指定任何头文件。</p>
<h4 id="步骤2：在C-中实现SimObject"><a href="#步骤2：在C-中实现SimObject" class="headerlink" title="步骤2：在C ++中实现SimObject"></a>步骤2：在C ++中实现SimObject</h4><p>接下来，我们需要创建hello_object.hh和hello_object.cc，它们将实现hello对象。</p>
<p>我们将从C ++对象的头文件开始。按照约定，gem5将所有头文件包装在＃ifndef /＃endif中，并带有文件名和其所在目录，因此没有循环包含。</p>
<p>我们在文件中唯一需要做的就是声明我们的类。由于HelloObject是SimObject，因此它必须继承自C ++ SimObject类。在大多数情况下，您的SimObject的父级将是SimObject的子类，而不是SimObject本身。</p>
<p>SimObject类指定许多虚函数。 但是，这些功能都不是纯虚函数，因此在最简单的情况下，除了构造函数外，无需实现任何功能。</p>
<p>所有SimObjects的构造函数都假定它将接收一个参数对象。这个参数对象是由构建系统自动创建的，并且基于SimObject的Python类，就像我们上面创建的那样。该参数类型的名称是根据对象的名称自动生成的。对于我们的“ HelloObject”，参数类型的名称为“ HelloObject ** Params **”。</p>
<p>下面列出了我们的简单头文件所需的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LEARNING_GEM5_HELLO_OBJECT_HH__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LEARNING_GEM5_HELLO_OBJECT_HH__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;params/HelloObject.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sim/sim_object.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloObject</span> :</span> <span class="keyword">public</span> SimObject</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    HelloObject(HelloObjectParams *p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __LEARNING_GEM5_HELLO_OBJECT_HH__</span></span></span><br></pre></td></tr></table></figure>

<p>您可以在<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/_downloads/hello_object1.hh">此处</a>找到完整的文件。</p>
<p>接下来，我们需要在.cc文件中实现两个功能，而不仅仅是一个。第一个函数是HelloObject的构造函数。在这里，我们只是将参数对象传递给SimObject父对象，并输出“ Hello world！”。</p>
<p>通常，您永远不会在gem5中使用std::cout。相反，您应该使用调试标志。在下一章中，我们将对其进行修改以改为使用调试标志。但是，由于它很简单，我们暂时仅使用std::cout。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_gem5/hello_object.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">HelloObject::HelloObject(HelloObjectParams *params) :</span><br><span class="line">    SimObject(params)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World! From a SimObject!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使SimObject完整，我们还必须实现另一个功能。我们必须为从SimObject Python声明隐式创建的参数类型实现一个函数，即create函数。此函数仅返回SimObject的新实例。 通常，此功能非常简单（如下所示）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HelloObject*</span><br><span class="line">HelloObjectParams::create()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HelloObject(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以在<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/_downloads/hello_object2.cc">此处</a>找到完整的文件。</p>
<p>如果忘记为SimObject添加create函数，则在编译时会出现链接器错误。 它将类似于以下内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;python&#x2F;m5&#x2F;internal&#x2F;param_HelloObject_wrap.o: In function &#96;_wrap_HelloObjectParams_create&#39;:</span><br><span class="line">&#x2F;local.chinook&#x2F;gem5&#x2F;gem5-tutorial&#x2F;gem5&#x2F;build&#x2F;X86&#x2F;python&#x2F;m5&#x2F;internal&#x2F;param_HelloObject_wrap.cc:3096: undefined reference to &#96;HelloObjectParams::create()&#39;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">scons: *** [build&#x2F;X86&#x2F;gem5.opt] Error 1</span><br><span class="line">scons: building terminated because of errors.</span><br></pre></td></tr></table></figure>

<p>对“ HelloObjectParams::create（）”的未定义引用意味着您需要为SimObject实现create函数。</p>
<h4 id="步骤3：注册SimObject和C-文件"><a href="#步骤3：注册SimObject和C-文件" class="headerlink" title="步骤3：注册SimObject和C ++文件"></a>步骤3：注册SimObject和C ++文件</h4><p>为了编译C ++文件和解析Python文件，我们需要将这些文件告知构建系统。gem5使用SCons作为构建系统，因此您只需在目录中使用SimObject的代码创建一个SConscript文件。如果该目录已经有一个SConscript文件，只需将以下声明添加到该文件中。</p>
<p>该文件只是普通的Python文件，因此您可以在该文件中编写所需的任何Python代码。一些脚本可能变得非常复杂。gem5利用此功能自动为SimObjects创建代码并编译特定于域的语言，例如SLICC和ISA语言。</p>
<p>在SConscript文件中，导入后会自动定义许多功能。请参阅有关该部分的内容…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Todo</span><br><span class="line">在SConscript构建系统上做了一节，讨论了所有功能。</span><br></pre></td></tr></table></figure>

<p>要编译新的SimObject，只需在src/learning_gem5目录中创建一个名称为“SConscript”的新文件。在此文件中，您必须声明SimObject和.cc文件。以下是必需的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Import(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">SimObject(<span class="string">&#x27;HelloObject.py&#x27;</span>)</span><br><span class="line">Source(<span class="string">&#x27;hello_object.cc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>您可以在<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/_downloads/SConscript1">此处</a>找到完整的文件。</p>
<h4 id="第4步：（重新）构建gem5"><a href="#第4步：（重新）构建gem5" class="headerlink" title="第4步：（重新）构建gem5"></a>第4步：（重新）构建gem5</h4><p>要编译和链接新文件，您只需要重新编译gem5。下面的示例假定您使用的是x86 ISA，但是我们的对象中没有任何东西需要ISA，因此，它可以与gem5的任何ISA一起使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons build&#x2F;X86&#x2F;gem5.opt</span><br></pre></td></tr></table></figure>

<h4 id="步骤5：创建配置脚本以使用新的SimObject"><a href="#步骤5：创建配置脚本以使用新的SimObject" class="headerlink" title="步骤5：创建配置脚本以使用新的SimObject"></a>步骤5：创建配置脚本以使用新的SimObject</h4><p>既然已经实现了SimObject，并且已将其编译到gem5中，则需要创建或修改Python配置文件以实例化对象。由于您的对象非常简单，因此不需要系统对象！除了Root对象外，不需要CPU，缓存或其他任何东西。所有gem5实例都需要一个Root对象。</p>
<p>逐步创建一个非常简单的配置脚本，首先，导入m5和所有已编译的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m5</span><br><span class="line"><span class="keyword">from</span> m5.objects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>接下来，您必须根据所有gem5实例的要求实例化Root对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root = Root(full_system = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>现在，您可以实例化创建的HelloObject。您需要做的就是调用Python“构造函数”。稍后，我们将研究如何通过Python构造函数指定参数。除了创建对象的实例化之外，还需要确保它是root对象的子对象。只有作为Root对象的子对象的SimObjects才会在C ++中实例化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.hello = HelloObject()</span><br></pre></td></tr></table></figure>

<p>最后，您需要在m5模块上调用实例化并实际运行仿真！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m5.instantiate()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Beginning simulation!&quot;</span>)</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line">print(<span class="string">&#x27;Exiting @ tick &#123;&#125; because &#123;&#125;&#x27;</span></span><br><span class="line">  .<span class="built_in">format</span>(m5.curTick(), exit_event.getCause()))</span><br></pre></td></tr></table></figure>

<p>您可以在<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/_downloads/run_hello.py">此处</a>找到完整的文件。</p>
<p>输出应类似于以下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled May  4 2016 11:37:41</span><br><span class="line">gem5 started May  4 2016 11:44:28</span><br><span class="line">gem5 executing on mustardseed.cs.wisc.edu, pid 22480</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt configs&#x2F;learning_gem5&#x2F;run_hello.py</span><br><span class="line"></span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">Hello World! From a SimObject!</span><br><span class="line">Beginning simulation!</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Exiting @ tick 18446744073709551615 because simulate() limit reached</span><br></pre></td></tr></table></figure>

<p>恭喜！您已经编写了第一个SimObject。在下一章中，我们将扩展此SimObject，并探索您可以使用SimObjects进行的操作。</p>
<h4 id="使用git分支"><a href="#使用git分支" class="headerlink" title="使用git分支"></a>使用git分支</h4><p>对于添加到gem5的每个新功能，通常都使用一个新的git分支。</p>
<p>添加新功能或修改gem5中的第一步时，是创建一个新分支来存储您的更改。  git分支的详细信息可以在<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell">Git书</a>中找到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hello-simobject</span><br></pre></td></tr></table></figure>

<h3 id="调试gem5"><a href="#调试gem5" class="headerlink" title="调试gem5"></a>调试gem5</h3><p>在前面的章节中，我们介绍了如何创建非常简单的SimObject。在本章中，我们将用gem5的调试支持将简单的打印内容替换为stdout。</p>
<p>gem5通过调试标志提供对printf样式的代码跟踪/调试的支持。这些标志允许每个组件具有许多调试打印语句，而不必同时启用所有这些语句。运行gem5时，您可以从命令行指定要启用的调试标志。</p>
<h4 id="使用调试标志"><a href="#使用调试标志" class="headerlink" title="使用调试标志"></a>使用调试标志</h4><p>例如，运行<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part1/simple_config.html#simple-config-chapter">“创建简单配置脚本”</a>中的第一个simple.py脚本时，如果启用DRAM调试标志，则会得到以下输出。 请注意，这会向控制台生成大量输出（大约7 MB）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt --debug-flags&#x3D;DRAM configs&#x2F;learning_gem5&#x2F;part1&#x2F;simple.py | head -n 50</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">DRAM device capacity (gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled Jan  3 2017 16:03:38</span><br><span class="line">gem5 started Jan  3 2017 16:09:53</span><br><span class="line">gem5 executing on chinook, pid 19223</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt --debug-flags&#x3D;DRAM configs&#x2F;learning_gem5&#x2F;part1&#x2F;simple.py</span><br><span class="line"></span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">      0: system.mem_ctrl: Memory capacity 536870912 (536870912) bytes</span><br><span class="line">      0: system.mem_ctrl: Row buffer size 8192 bytes with 128 columns per row buffer</span><br><span class="line">      0: system.remote_gdb.listener: listening for remote gdb #0 on port 7000</span><br><span class="line">Beginning simulation!</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">      0: system.mem_ctrl: recvTimingReq: request ReadReq addr 400 size 8</span><br><span class="line">      0: system.mem_ctrl: Read queue limit 32, current size 0, entries needed 1</span><br><span class="line">      0: system.mem_ctrl: Address: 400 Rank 0 Bank 0 Row 0</span><br><span class="line">      0: system.mem_ctrl: Read queue limit 32, current size 0, entries needed 1</span><br><span class="line">      0: system.mem_ctrl: Adding to read queue</span><br><span class="line">      0: system.mem_ctrl: Request scheduled immediately</span><br><span class="line">      0: system.mem_ctrl: Single request, going to a free rank</span><br><span class="line">      0: system.mem_ctrl: Timing access to addr 400, rank&#x2F;bank&#x2F;row 0 0 0</span><br><span class="line">      0: system.mem_ctrl: Activate at tick 0</span><br><span class="line">      0: system.mem_ctrl: Activate bank 0, rank 0 at tick 0, now got 1 active</span><br><span class="line">      0: system.mem_ctrl: Access to 400, ready at 46250 bus busy until 46250.</span><br><span class="line">  46250: system.mem_ctrl: processRespondEvent(): Some req has reached its readyTime</span><br><span class="line">  46250: system.mem_ctrl: number of read entries for rank 0 is 0</span><br><span class="line">  46250: system.mem_ctrl: Responding to Address 400..   46250: system.mem_ctrl: Done</span><br><span class="line">  77000: system.mem_ctrl: recvTimingReq: request ReadReq addr 400 size 8</span><br><span class="line">  77000: system.mem_ctrl: Read queue limit 32, current size 0, entries needed 1</span><br><span class="line">  77000: system.mem_ctrl: Address: 400 Rank 0 Bank 0 Row 0</span><br><span class="line">  77000: system.mem_ctrl: Read queue limit 32, current size 0, entries needed 1</span><br><span class="line">  77000: system.mem_ctrl: Adding to read queue</span><br><span class="line">  77000: system.mem_ctrl: Request scheduled immediately</span><br><span class="line">  77000: system.mem_ctrl: Single request, going to a free rank</span><br><span class="line">  77000: system.mem_ctrl: Timing access to addr 400, rank&#x2F;bank&#x2F;row 0 0 0</span><br><span class="line">  77000: system.mem_ctrl: Access to 400, ready at 101750 bus busy until 101750.</span><br><span class="line"> 101750: system.mem_ctrl: processRespondEvent(): Some req has reached its readyTime</span><br><span class="line"> 101750: system.mem_ctrl: number of read entries for rank 0 is 0</span><br><span class="line"> 101750: system.mem_ctrl: Responding to Address 400..  101750: system.mem_ctrl: Done</span><br><span class="line"> 132000: system.mem_ctrl: recvTimingReq: request ReadReq addr 400 size 8</span><br><span class="line"> 132000: system.mem_ctrl: Read queue limit 32, current size 0, entries needed 1</span><br><span class="line"> 132000: system.mem_ctrl: Address: 400 Rank 0 Bank 0 Row 0</span><br><span class="line"> 132000: system.mem_ctrl: Read queue limit 32, current size 0, entries needed 1</span><br><span class="line"> 132000: system.mem_ctrl: Adding to read queue</span><br><span class="line"> 132000: system.mem_ctrl: Request scheduled immediately</span><br><span class="line"> 132000: system.mem_ctrl: Single request, going to a free rank</span><br><span class="line"> 132000: system.mem_ctrl: Timing access to addr 400, rank&#x2F;bank&#x2F;row 0 0 0</span><br><span class="line"> 132000: system.mem_ctrl: Access to 400, ready at 156750 bus busy until 156750.</span><br><span class="line"> 156750: system.mem_ctrl: processRespondEvent(): Some req has reached its readyTime</span><br><span class="line"> 156750: system.mem_ctrl: number of read entries for rank 0 is 0</span><br></pre></td></tr></table></figure>

<p> 或者，您可能希望根据CPU正在执行的确切指令进行调试。为此，Exec调试标志可能会很有用。该调试标志显示了模拟CPU如何执行每条指令的详细信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt --debug-flags&#x3D;Exec configs&#x2F;learning_gem5&#x2F;part1&#x2F;simple.py | head -n 50</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled Jan  3 2017 16:03:38</span><br><span class="line">gem5 started Jan  3 2017 16:11:47</span><br><span class="line">gem5 executing on chinook, pid 19234</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt --debug-flags&#x3D;Exec configs&#x2F;learning_gem5&#x2F;part1&#x2F;simple.py</span><br><span class="line"></span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">      0: system.remote_gdb.listener: listening for remote gdb #0 on port 7000</span><br><span class="line">warn: ClockedObject: More than one power state change request encountered within the same simulation tick</span><br><span class="line">Beginning simulation!</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">  77000: system.cpu T0 : @_start    : xor   rbp, rbp</span><br><span class="line">  77000: system.cpu T0 : @_start.0  :   XOR_R_R : xor   rbp, rbp, rbp : IntAlu :  D&#x3D;0x0000000000000000</span><br><span class="line"> 132000: system.cpu T0 : @_start+3    : mov r9, rdx</span><br><span class="line"> 132000: system.cpu T0 : @_start+3.0  :   MOV_R_R : mov   r9, r9, rdx : IntAlu :  D&#x3D;0x0000000000000000</span><br><span class="line"> 187000: system.cpu T0 : @_start+6    : pop rsi</span><br><span class="line"> 187000: system.cpu T0 : @_start+6.0  :   POP_R : ld   t1, SS:[rsp] : MemRead :  D&#x3D;0x0000000000000001 A&#x3D;0x7fffffffee30</span><br><span class="line"> 250000: system.cpu T0 : @_start+6.1  :   POP_R : addi   rsp, rsp, 0x8 : IntAlu :  D&#x3D;0x00007fffffffee38</span><br><span class="line"> 250000: system.cpu T0 : @_start+6.2  :   POP_R : mov   rsi, rsi, t1 : IntAlu :  D&#x3D;0x0000000000000001</span><br><span class="line"> 360000: system.cpu T0 : @_start+7    : mov rdx, rsp</span><br><span class="line"> 360000: system.cpu T0 : @_start+7.0  :   MOV_R_R : mov   rdx, rdx, rsp : IntAlu :  D&#x3D;0x00007fffffffee38</span><br><span class="line"> 415000: system.cpu T0 : @_start+10    : and        rax, 0xfffffffffffffff0</span><br><span class="line"> 415000: system.cpu T0 : @_start+10.0  :   AND_R_I : limm   t1, 0xfffffffffffffff0 : IntAlu :  D&#x3D;0xfffffffffffffff0</span><br><span class="line"> 415000: system.cpu T0 : @_start+10.1  :   AND_R_I : and   rsp, rsp, t1 : IntAlu :  D&#x3D;0x0000000000000000</span><br><span class="line"> 470000: system.cpu T0 : @_start+14    : push       rax</span><br><span class="line"> 470000: system.cpu T0 : @_start+14.0  :   PUSH_R : st   rax, SS:[rsp + 0xfffffffffffffff8] : MemWrite :  D&#x3D;0x0000000000000000 A&#x3D;0x7fffffffee28</span><br><span class="line"> 491000: system.cpu T0 : @_start+14.1  :   PUSH_R : subi   rsp, rsp, 0x8 : IntAlu :  D&#x3D;0x00007fffffffee28</span><br><span class="line"> 546000: system.cpu T0 : @_start+15    : push       rsp</span><br><span class="line"> 546000: system.cpu T0 : @_start+15.0  :   PUSH_R : st   rsp, SS:[rsp + 0xfffffffffffffff8] : MemWrite :  D&#x3D;0x00007fffffffee28 A&#x3D;0x7fffffffee20</span><br><span class="line"> 567000: system.cpu T0 : @_start+15.1  :   PUSH_R : subi   rsp, rsp, 0x8 : IntAlu :  D&#x3D;0x00007fffffffee20</span><br><span class="line"> 622000: system.cpu T0 : @_start+16    : mov        r15, 0x40a060</span><br><span class="line"> 622000: system.cpu T0 : @_start+16.0  :   MOV_R_I : limm   r8, 0x40a060 : IntAlu :  D&#x3D;0x000000000040a060</span><br><span class="line"> 732000: system.cpu T0 : @_start+23    : mov        rdi, 0x409ff0</span><br><span class="line"> 732000: system.cpu T0 : @_start+23.0  :   MOV_R_I : limm   rcx, 0x409ff0 : IntAlu :  D&#x3D;0x0000000000409ff0</span><br><span class="line"> 842000: system.cpu T0 : @_start+30    : mov        rdi, 0x400274</span><br><span class="line"> 842000: system.cpu T0 : @_start+30.0  :   MOV_R_I : limm   rdi, 0x400274 : IntAlu :  D&#x3D;0x0000000000400274</span><br><span class="line"> 952000: system.cpu T0 : @_start+37    : call       0x9846</span><br><span class="line"> 952000: system.cpu T0 : @_start+37.0  :   CALL_NEAR_I : limm   t1, 0x9846 : IntAlu :  D&#x3D;0x0000000000009846</span><br><span class="line"> 952000: system.cpu T0 : @_start+37.1  :   CALL_NEAR_I : rdip   t7, %ctrl153,  : IntAlu :  D&#x3D;0x00000000004001ba</span><br><span class="line"> 952000: system.cpu T0 : @_start+37.2  :   CALL_NEAR_I : st   t7, SS:[rsp + 0xfffffffffffffff8] : MemWrite :  D&#x3D;0x00000000004001ba A&#x3D;0x7fffffffee18</span><br><span class="line"> 973000: system.cpu T0 : @_start+37.3  :   CALL_NEAR_I : subi   rsp, rsp, 0x8 : IntAlu :  D&#x3D;0x00007fffffffee18</span><br><span class="line"> 973000: system.cpu T0 : @_start+37.4  :   CALL_NEAR_I : wrip   , t7, t1 : IntAlu :</span><br><span class="line">1042000: system.cpu T0 : @__libc_start_main    : push       r15</span><br><span class="line">1042000: system.cpu T0 : @__libc_start_main.0  :   PUSH_R : st   r15, SS:[rsp + 0xfffffffffffffff8] : MemWrite :  D&#x3D;0x0000000000000000 A&#x3D;0x7fffffffee10</span><br><span class="line">1063000: system.cpu T0 : @__libc_start_main.1  :   PUSH_R : subi   rsp, rsp, 0x8 : IntAlu :  D&#x3D;0x00007fffffffee10</span><br><span class="line">1118000: system.cpu T0 : @__libc_start_main+2    : movsxd   rax, rsi</span><br><span class="line">1118000: system.cpu T0 : @__libc_start_main+2.0  :   MOVSXD_R_R : sexti   rax, rsi, 0x1f : IntAlu :  D&#x3D;0x0000000000000001</span><br><span class="line">1173000: system.cpu T0 : @__libc_start_main+5    : mov      r15, r9</span><br><span class="line">1173000: system.cpu T0 : @__libc_start_main+5.0  :   MOV_R_R : mov   r15, r15, r9 : IntAlu :  D&#x3D;0x0000000000000000</span><br><span class="line">1228000: system.cpu T0 : @__libc_start_main+8    : push     r14</span><br></pre></td></tr></table></figure>

<p>实际上，Exec标志实际上是多个调试标志的集合。通过使用–debug-help参数运行gem5，可以看到此信息以及所有可用的调试标志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt --debug-help</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Base Flags:</span><br><span class="line">Activity: None</span><br><span class="line">AddrRanges: None</span><br><span class="line">Annotate: State machine annotation debugging</span><br><span class="line">AnnotateQ: State machine annotation queue debugging</span><br><span class="line">AnnotateVerbose: Dump all state machine annotation details</span><br><span class="line">BaseXBar: None</span><br><span class="line">Branch: None</span><br><span class="line">Bridge: None</span><br><span class="line">CCRegs: None</span><br><span class="line">CMOS: Accesses to CMOS devices</span><br><span class="line">Cache: None</span><br><span class="line">CachePort: None</span><br><span class="line">CacheRepl: None</span><br><span class="line">CacheTags: None</span><br><span class="line">CacheVerbose: None</span><br><span class="line">Checker: None</span><br><span class="line">Checkpoint: None</span><br><span class="line">ClockDomain: None</span><br><span class="line">...</span><br><span class="line">Compound Flags:</span><br><span class="line">AnnotateAll: All Annotation flags</span><br><span class="line">    Annotate, AnnotateQ, AnnotateVerbose</span><br><span class="line">CacheAll: None</span><br><span class="line">    Cache, CachePort, CacheRepl, CacheVerbose, HWPrefetch</span><br><span class="line">DiskImageAll: None</span><br><span class="line">    DiskImageRead, DiskImageWrite</span><br><span class="line">...</span><br><span class="line">XBar: None</span><br><span class="line">    BaseXBar, CoherentXBar, NoncoherentXBar, SnoopFilter    XBar: None</span><br><span class="line">    BaseXBar, CoherentXBar, NoncoherentXBar, SnoopFilter</span><br></pre></td></tr></table></figure>

<h4 id="添加一个新的调试标志"><a href="#添加一个新的调试标志" class="headerlink" title="添加一个新的调试标志"></a>添加一个新的调试标志</h4><p>在前面的章节中，我们使用了一个简单的std::cout从SimObject中进行打印。虽然可以在gem5中使用普通的C/C++ I/O，但强烈建议不要这样做。因此，我们现在将使用gem5的调试工具替换它。</p>
<p>创建新的调试标志时，我们首先必须在SConscript文件中对其进行声明。将以下内容添加到你的hello对象代码目录中（src/learning_gem5/）的SConscript文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DebugFlag(&#39;Hello&#39;)</span><br></pre></td></tr></table></figure>

<p>这声明调试标志为“ Hello”。现在，我们可以在SimObject的调试语句中使用它。</p>
<p>通过在SConscript文件中声明该标志，将自动生成一个调试标头，使我们可以使用调试标志。头文件在debug目录中，并且具有与我们在SConscript文件中声明的名称相同的名称（和大小写）。因此，我们需要在计划使用debug标志的任何文件中包含自动生成的头文件。</p>
<p>在hello_object.cc文件中，我们需要包括头文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;debug/Hello.hh&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>现在我们已经包含了必要的头文件，让我们将std::cout调用替换为这样的调试语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DPRINTF(Hello, <span class="string">&quot;Created the hello object\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>DPRINTF是C ++宏。第一个参数是已在SConscript文件中声明的调试标志。我们可以使用标志Hello，因为我们在src/learning_gem5/SConscript文件中声明了它。其余参数是可变的，可以是传递给printf语句的任何参数。</p>
<p>现在，如果重新编译gem5并使用“Hello”调试标志运行它，您将得到以下结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;X86&#x2F;gem5.opt --debug-flags&#x3D;Hello configs&#x2F;learning_gem5&#x2F;part2&#x2F;run_hello.py</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  http:&#x2F;&#x2F;gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 compiled Jan  4 2017 09:40:10</span><br><span class="line">gem5 started Jan  4 2017 09:41:01</span><br><span class="line">gem5 executing on chinook, pid 29078</span><br><span class="line">command line: build&#x2F;X86&#x2F;gem5.opt --debug-flags&#x3D;Hello configs&#x2F;learning_gem5&#x2F;part2&#x2F;run_hello.py</span><br><span class="line"></span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">      0: hello: Created the hello object</span><br><span class="line">Beginning simulation!</span><br><span class="line">info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Exiting @ tick 18446744073709551615 because simulate() limit reached</span><br></pre></td></tr></table></figure>

<p>您可以在<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/_downloads/SConscript">这里</a>找到更新的SConcript文件，并在<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/_downloads/hello_object.cc">这里</a>找到更新的hello对象代码。</p>
<h4 id="调试输出"><a href="#调试输出" class="headerlink" title="调试输出"></a>调试输出</h4><p>略</p>
<h4 id="使用DPRINTF以外的功能"><a href="#使用DPRINTF以外的功能" class="headerlink" title="使用DPRINTF以外的功能"></a>使用DPRINTF以外的功能</h4><p>DPRINTF是gem5中最常用的调试功能。但是，gem5提供了许多其他功能，这些功能在特定情况下很有用。</p>
<ul>
<li><p>DPRINTF(Flag,__VA_ARGS__)<br>带有一个标志和一个格式字符串以及任何格式参数。此函数要求当前作用域中有一个name（）函数（例如，从SimObject成员函数调用）。仅在启用标志时才打印格式化的字符串。</p>
</li>
<li><p>DTRACE(Flag)<br>如果启用了标志（Flag），则返回true，否则返回false。仅当启用调试标志（标志）时，这对于执行某些代码很有用。</p>
</li>
<li><p>DDUMP(Flag,data,count)<br>打印长度计数字节的二进制数据（数据）。以用户可读的方式将其格式化为十六进制。该宏还假定调用范围包含一个name（）函数。</p>
</li>
<li><p>DPRINTFS(Flag,SimObject,__VA_ARGS__)<br>像DPRINTF（）一样，只是需要一个额外的参数，该参数是具有name（）函数的对象，通常是SimObject。对于从具有指向其所有者的指针的SimObject的私有子类中进行调试，此功能很有用。</p>
</li>
<li><p>DPRINTFR(Flag,__VA_ARGS__)<br>此函数输出调试语句，而不输出名称。对于在不是没有name（）函数的SimObjects的对象中使用调试语句，这很有用。</p>
</li>
<li><p>DDUMPN(data,count)</p>
</li>
<li><p>DPRINTFN(__VA_ARGS__)<br>这些函数与以前的函数DDUMP（），DPRINTF（）和DPRINTFR（）相似，不同之处在于它们不使用标志作为参数。因此，无论何时启用调试，这些语句将始终打印。</p>
</li>
<li><p>DPRINTFNR(__VA_ARGS__)</p>
<p>只有在“ opt”或“ debug”模式下编译gem5时，才能启用所有这些功能。所有其他模式都为上述功能使用空的占位符宏。因此，如果要使用调试标志，则必须使用“ gem5.opt”或“ gem5.debug”。</p>
</li>
</ul>
<h3 id="事件驱动的编程"><a href="#事件驱动的编程" class="headerlink" title="事件驱动的编程"></a>事件驱动的编程</h3><p>gem5是事件驱动的模拟器。在本章中，我们将探讨如何创建和安排事件。我们将从<a target="_blank" rel="noopener" href="http://learning.gem5.org/book/part2/helloobject.html#hello-simobject-chapter">创建一个非常简单的SimObject</a>的简单HelloObject进行构建。</p>
<h4 id="创建一个简单的事件回调"><a href="#创建一个简单的事件回调" class="headerlink" title="创建一个简单的事件回调"></a>创建一个简单的事件回调</h4><p>在gem5的事件驱动模型中，每个事件都有一个回调函数来处理该事件。通常，这是一个从Event继承的类。但是，gem5提供了用于创建简单事件的包装器功能。</p>
<p>在HelloObject的头文件中，我们只需要声明一个每次事件触发时要执行的新函数（processEvent（））。此函数必须不带任何参数，并且不返回任何值。</p>
<p>接下来，我们添加一个Event实例。 在这种情况下，我们将使用EventFunctionWrapper，它允许我们执行任何功能。</p>
<p>我们还添加了一个startup（）函数，下面将对其进行说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloObject</span> :</span> <span class="keyword">public</span> SimObject</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processEvent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    EventFunctionWrapper event;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    HelloObject(HelloObjectParams *p);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来，我们必须在HelloObject的构造函数中构造此事件。EventFuntionWrapper具有两个参数，一个要执行的函数和一个名称。该名称通常是拥有事件的SimObject的名称。打印名称时，名称末尾会自动附加一个“ .wrapped_function_event”。</p>
<p>第一个参数只是一个不带参数且没有返回值的函数（std :: function &lt;void（void）&gt;）。通常，这是一个调用成员函数的简单lambda函数。但是，它可以是您想要的任何功能。 下面，我们在lambda（[this]）中对其进行介绍，以便我们可以调用该类实例的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HelloObject::HelloObject(HelloObjectParams *params) :</span><br><span class="line">    SimObject(params), event([<span class="keyword">this</span>]&#123;processEvent();&#125;, name())</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(Hello, <span class="string">&quot;Created the hello object\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还必须定义流程功能的实现。 在这种情况下，如果要调试，我们将只打印一些内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">HelloObject::processEvent()</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(Hello, <span class="string">&quot;Hello world! Processing the event!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调度事件"><a href="#调度事件" class="headerlink" title="调度事件"></a>调度事件</h4><p>最后，对于要处理的事件，我们首先必须调度事件。为此，我们使用schedule（）函数。此函数在将来的某个时间安排某个事件的某个实例（事件驱动的模拟不允许事件在过去执行）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schedule(Event *event, Tick when)</span><br><span class="line"><span class="comment">// 安排事件（事件）在何时执行。此函数将事件放入事件队列，并在tick时执行事件。</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/Learning-Gem5%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/" data-id="cl8l2yd7i000exzwseayz5mei" data-title="Learning Gem5中文翻译" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" rel="tag">计算机体系结构</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/28/Intel-Pin-Tool-Use-Note/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Intel Pin Tool Use Note
        
      </div>
    </a>
  
  
    <a href="/2021/02/26/Learning%20Gem5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">技术博客</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" rel="tag">计算机体系结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" style="font-size: 10px;">计算机体系结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/28/Intel-SDM/">Intel® 64 and IA-32 Architectures Software Developer Manuals</a>
          </li>
        
          <li>
            <a href="/2021/06/28/Scratchpad-Memory/">Scratchpad Memory</a>
          </li>
        
          <li>
            <a href="/2021/06/02/Computer-Architecture-Learning-Notes/">Computer_Architecture_Learning_Notes</a>
          </li>
        
          <li>
            <a href="/2021/04/28/Intel-Pin-Tool-Use-Note/">Intel Pin Tool Use Note</a>
          </li>
        
          <li>
            <a href="/2021/03/01/Learning-Gem5%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/">Learning Gem5中文翻译</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>